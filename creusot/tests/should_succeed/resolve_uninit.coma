
module ResolveUninit_MaybeUninit
  type t
  let%span sresolve_uninit0 = "../resolve_uninit.rs" 8 12 8 24
  let%span sresolve_uninit1 = "../resolve_uninit.rs" 7 9 9 5
  let%span sresolve_uninit2 = "../resolve_uninit.rs" 9 5 9 5
  let%span sresolve_uninit3 = "../resolve_uninit.rs" 5 41 5 42
  let%span sresolve_uninit4 = "../resolve_uninit.rs" 5 50 5 51
  let%span span5 = "../../../../creusot-contracts/src/std/default.rs" 13 26 13 45
  let%span span6 = "" 0 0 0 0
  predicate invariant'0 (self : t)
  let rec invariant'0 (self:t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : t)
  let rec inv'0 (_x:t) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ] 
  axiom inv'0 : forall x : t . inv'0 x = true
  use prelude.Intrinsic
  predicate resolve'0 (self : t)
  let rec resolve'0 (self:t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  predicate is_default'0 (self : t)
  let rec is_default'0 (self:t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_default'0 self} (! return' {result}) ]
    
  let rec default'0 (_1:()) (return'  (ret:t))= any
    [ return' (result:t)-> {[%#span6] inv'0 result} {[%#span5] is_default'0 result} (! return' {result}) ]
    
  let rec maybe_uninit (b:bool) (y:t) (return'  (ret:t))= {[%#sresolve_uninit3] inv'0 y}
    (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb6) | br1 -> {b} (! bb1) ] 
    | bb1 = s0 [ s0 = default'0 {[%#sresolve_uninit0] ()} (fun (_ret':t) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = s0
      [ s0 =  [ &x <- _6 ] (any [ any_ (_any:t)-> (!  [ &_6 <- _any ] s1) ] )
      | s1 = {[@expl:type invariant] inv'0 x} s2
      | s2 = -{resolve'0 x}- s3
      | s3 = bb5 ]
      
    | bb5 = s0 [ s0 =  [ &_4 <- [%#sresolve_uninit1] () ] s1 | s1 = bb7 ] 
    | bb6 = s0 [ s0 =  [ &_4 <- [%#sresolve_uninit2] () ] s1 | s1 = bb7 ] 
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &x <- y ] (any [ any_ (_any:t)-> (!  [ &y <- _any ] s1) ] ) | s1 = bb10 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- x ] (any [ any_ (_any:t)-> (!  [ &x <- _any ] s1) ] ) | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t = any_l ()
    | & b : bool = b
    | & y : t = y
    | & x : t = any_l ()
    | & _4 : () = any_l ()
    | & _6 : t = any_l () ]
     [ return' (result:t)-> {[@expl:postcondition] [%#sresolve_uninit4] inv'0 result} (! return' {result}) ] 
end
module ResolveUninit_InitJoin
  let%span sresolve_uninit0 = "../resolve_uninit.rs" 19 9 23 5
  let%span sresolve_uninit1 = "../resolve_uninit.rs" 23 11 25 5
  let%span sresolve_uninit2 = "../resolve_uninit.rs" 27 9 27 10
  let%span sresolve_uninit3 = "../resolve_uninit.rs" 28 17 28 18
  let%span sresolve_uninit4 = "../resolve_uninit.rs" 15 38 29 1
  let%span sresolve_uninit5 = "../resolve_uninit.rs" 28 4 28 19
  let%span span6 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  use prelude.Intrinsic
  use prelude.Borrow
  use prelude.Int32
  predicate resolve'0 (self : borrowed int32) =
    [%#span6]  ^ self =  * self
  let rec resolve'0 (self:borrowed int32) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  let rec init_join (b:bool) (x:int32) (return'  (ret:()))= (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb2) | br1 -> {b} (! bb1) ] 
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <int32> {x} (fun (_ret':borrowed int32) ->  [ &_8 <- _ret' ]  [ &x <-  ^ _8 ] s1)
      | s1 = Borrow.borrow_final <int32> { * _8} {Borrow.get_id _8}
          (fun (_ret':borrowed int32) ->  [ &_7 <- _ret' ]  [ &_8 <- { _8 with current = ( ^ _7) ; } ] s2)
      | s2 =  [ &z <- _7 ] (any [ any_ (_any:borrowed int32)-> (!  [ &_7 <- _any ] s3) ] )
      | s3 = -{resolve'0 _8}- s4
      | s4 = Borrow.borrow_final <int32> { * z} {Borrow.get_id z}
          (fun (_ret':borrowed int32) ->  [ &_10 <- _ret' ]  [ &z <- { z with current = ( ^ _10) ; } ] s5)
      | s5 = Borrow.borrow_final <int32> { * _10} {Borrow.get_id _10}
          (fun (_ret':borrowed int32) ->  [ &_9 <- _ret' ]  [ &_10 <- { _10 with current = ( ^ _9) ; } ] s6)
      | s6 =  [ &y <- _9 ] (any [ any_ (_any:borrowed int32)-> (!  [ &_9 <- _any ] s7) ] )
      | s7 = -{resolve'0 _10}- s8
      | s8 =  [ &_5 <- [%#sresolve_uninit0] () ] s9
      | s9 = bb7 ]
      
    | bb7 = s0 [ s0 = -{resolve'0 z}- s1 | s1 = bb3 ] 
    | bb2 = s0
      [ s0 = Borrow.borrow_mut <int32> {x} (fun (_ret':borrowed int32) ->  [ &_12 <- _ret' ]  [ &x <-  ^ _12 ] s1)
      | s1 = Borrow.borrow_final <int32> { * _12} {Borrow.get_id _12}
          (fun (_ret':borrowed int32) ->  [ &_11 <- _ret' ]  [ &_12 <- { _12 with current = ( ^ _11) ; } ] s2)
      | s2 =  [ &y <- _11 ] (any [ any_ (_any:borrowed int32)-> (!  [ &_11 <- _any ] s3) ] )
      | s3 = -{resolve'0 _12}- s4
      | s4 =  [ &_5 <- [%#sresolve_uninit1] () ] s5
      | s5 = bb3 ]
      
    | bb3 = s0
      [ s0 =  [ &y <- { y with current = ([%#sresolve_uninit2] (5 : int32)) ; } ] s1
      | s1 = -{resolve'0 y}- s2
      | s2 = Int32.eq {x} {[%#sresolve_uninit3] (5 : int32)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s3)
      | s3 = any [ br0 -> {_14 = false} (! bb5) | br1 -> {_14} (! bb4) ]  ]
      
    | bb4 = s0 [ s0 =  [ &_0 <- [%#sresolve_uninit4] () ] s1 | s1 = return' {_0} ] 
    | bb5 = {[%#sresolve_uninit5] false} any ]
    )
    [ & _0 : () = any_l ()
    | & b : bool = b
    | & x : int32 = x
    | & y : borrowed int32 = any_l ()
    | & z : borrowed int32 = any_l ()
    | & _5 : () = any_l ()
    | & _7 : borrowed int32 = any_l ()
    | & _8 : borrowed int32 = any_l ()
    | & _9 : borrowed int32 = any_l ()
    | & _10 : borrowed int32 = any_l ()
    | & _11 : borrowed int32 = any_l ()
    | & _12 : borrowed int32 = any_l ()
    | & _14 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end

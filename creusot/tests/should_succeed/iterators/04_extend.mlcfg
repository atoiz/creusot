
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module CreusotContracts_Std1_Iter_IteratorSpec_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface
  type self
  predicate completed (self : self)
end
module CreusotContracts_Std1_Iter_IteratorSpec_Completed
  type self
  predicate completed (self : self)
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type core_ptr_nonnull_nonnull_type 't =
    | Core_Ptr_NonNull_NonNull_Type opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type core_marker_phantomdata_type 't =
    | Core_Marker_PhantomData_Type
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type
  type core_ptr_unique_unique_type 't =
    | Core_Ptr_Unique_Unique_Type (Core_Ptr_NonNull_NonNull_Type.core_ptr_nonnull_nonnull_type 't) (Core_Marker_PhantomData_Type.core_marker_phantomdata_type 't)
    
end
module Alloc_RawVec_RawVec_Type
  use mach.int.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type
  type alloc_rawvec_rawvec_type 't 'a =
    | Alloc_RawVec_RawVec_Type (Core_Ptr_Unique_Unique_Type.core_ptr_unique_unique_type 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type
  type alloc_vec_vec_type 't 'a =
    | Alloc_Vec_Vec_Type (Alloc_RawVec_RawVec_Type.alloc_rawvec_rawvec_type 't 'a) usize
    
end
module CreusotContracts_Std1_Vec_Impl0_Model_Interface
  type t
  type a
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type
  function model (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model
  type t
  type a
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type
  function model (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : Seq.seq t
  axiom model_spec : forall self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a . Seq.length (model self) <= 18446744073709551615
end
module CreusotContracts_Logic_Model_Model_ModelTy_Type
  type self
  type modelTy
end
module CreusotContracts_Logic_Model_Model_Model_Interface
  type self
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Model_Model
  type self
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  function model (self : borrowed t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model
  type t
  use prelude.Borrow
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : borrowed t) : ModelTy0.modelTy =
    Model0.model ( * self)
end
module Alloc_Alloc_Global_Type
  type alloc_alloc_global_type  =
    | Alloc_Alloc_Global_Type
    
end
module CreusotContracts_Std1_Vec_Impl0_ModelTy_Type
  type t
  type a
  use seq.Seq
  type modelTy  =
    Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0
  type t
  type a
end
module CreusotContracts_Logic_Model_Impl1
  type t
end
module CreusotContracts_Std1_Iter_IteratorSpec_ProducesRefl_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = self,
  type Item0.item = Item0.item
  function produces_refl (a : self) : ()
end
module CreusotContracts_Std1_Iter_IteratorSpec_ProducesRefl
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = self,
  type Item0.item = Item0.item
  function produces_refl (a : self) : ()
  axiom produces_refl_spec : forall a : self . Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_IteratorSpec_ProducesTrans_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = self,
  type Item0.item = Item0.item
  function produces_trans (a : self) (ab : Seq.seq Item0.item) (b : self) (bc : Seq.seq Item0.item) (c : self) : ()
end
module CreusotContracts_Std1_Iter_IteratorSpec_ProducesTrans
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = self,
  type Item0.item = Item0.item
  function produces_trans (a : self) (ab : Seq.seq Item0.item) (b : self) (bc : Seq.seq Item0.item) (c : self) : ()
  axiom produces_trans_spec : forall a : self, ab : Seq.seq Item0.item, b : self, bc : Seq.seq Item0.item, c : self . Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  val into_iter [@cfg:stackify] (self : i) : i
    ensures { result = self }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter
  type i
  val into_iter [@cfg:stackify] (self : i) : i
    ensures { result = self }
    
end
module Core_Option_Option_Type
  type core_option_option_type 't =
    | Core_Option_Option_None_Type
    | Core_Option_Option_Some_Type 't
    
  let function core_option_option_type_Some_0 (self : core_option_option_type 't) : 't
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Option_Option_None_Type -> any 't
      | Core_Option_Option_Some_Type a -> a
      end
end
module Core_Iter_Traits_Iterator_Iterator_Next_Interface
  type self
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = self,
  type Item0.item = Item0.item
  clone CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface as Completed0 with type self = self
  val next [@cfg:stackify] (self : borrowed self) : Core_Option_Option_Type.core_option_option_type Item0.item
    ensures { match (result) with
      | Core_Option_Option_Type.Core_Option_Option_None_Type -> Completed0.completed ( * self)
      | Core_Option_Option_Type.Core_Option_Option_Some_Type v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self) /\ not Completed0.completed ( * self)
      end }
    
end
module Core_Iter_Traits_Iterator_Iterator_Next
  type self
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with type self = self
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = self,
  type Item0.item = Item0.item
  clone CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface as Completed0 with type self = self
  val next [@cfg:stackify] (self : borrowed self) : Core_Option_Option_Type.core_option_option_type Item0.item
    ensures { match (result) with
      | Core_Option_Option_Type.Core_Option_Option_None_Type -> Completed0.completed ( * self)
      | Core_Option_Option_Type.Core_Option_Option_Some_Type v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self) /\ not Completed0.completed ( * self)
      end }
    
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
end
module Alloc_Vec_Impl1_Push_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val push [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t a)) (value : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model0.model ( * self)) value }
    
end
module Alloc_Vec_Impl1_Push
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val push [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t a)) (value : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model0.model ( * self)) value }
    
end
module Core_Iter_Traits_Collect_Impl0
  type i
end
module CreusotContracts_Logic_Resolve_Impl1
  type t
end
module CreusotContracts_Logic_Ghost_Ghost_Type
  use prelude.Opaque
  type creusotcontracts_logic_ghost_ghost_type 't =
    | CreusotContracts_Logic_Ghost_Ghost_Type opaque_ptr
    
end
module C04Extend_Extend_Interface
  type t
  type i
  use seq.Seq
  use prelude.Borrow
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy_Type as ModelTy0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  clone CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface as Completed0 with type self = i
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = i, type Item0.item = t
  val extend [@cfg:stackify] (v : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))) (i : i) : ()
    ensures { [#"../04_extend.rs" 7 0 7 93] exists p : (Seq.seq t) . exists f : (i) . Produces0.produces i p f /\ Completed0.completed f /\ Model0.model ( ^ v) = Seq.(++) (Model1.model v) p }
    
end
module C04Extend_Extend
  type t
  type i
  use seq.Seq
  use prelude.Borrow
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy_Type as ModelTy0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces as Produces0 with type self = i, type Item0.item = t
  clone CreusotContracts_Std1_Iter_IteratorSpec_ProducesTrans as ProducesTrans0 with type self = i,
  predicate Produces0.produces = Produces0.produces, type Item0.item = t, axiom .
  clone CreusotContracts_Std1_Iter_IteratorSpec_ProducesRefl as ProducesRefl0 with type self = i,
  predicate Produces0.produces = Produces0.produces, type Item0.item = t, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Iter_IteratorSpec_Completed as Completed0 with type self = i
  use mach.int.Int
  use prelude.IntSize
  use CreusotContracts_Logic_Ghost_Ghost_Type
  use Core_Option_Option_Type
  clone Alloc_Vec_Impl1_Push_Interface as Push0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve6 with type self = t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve5 with type self = Core_Option_Option_Type.core_option_option_type t
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)
  clone Core_Iter_Traits_Iterator_Iterator_Next_Interface as Next0 with type self = i, type Item0.item = t,
  predicate Completed0.completed = Completed0.completed, predicate Produces0.produces = Produces0.produces
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve3 with type self = Seq.seq t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = i
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with type i = i
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = i
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))
  let rec cfg extend [@cfg:stackify] [#"../04_extend.rs" 8 0 9 28] (v : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))) (i : i) : ()
    ensures { [#"../04_extend.rs" 7 0 7 93] exists p : (Seq.seq t) . exists f : (i) . Produces0.produces i p f /\ Completed0.completed f /\ Model0.model ( ^ v) = Seq.(++) (Model1.model v) p }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var v_1 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var i_2 : i;
  ghost var old_v_4 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _7 : ();
  var iter_8 : i;
  var _9 : i;
  ghost var iter_old_10 : i;
  var _13 : ();
  ghost var produced_14 : Seq.seq t;
  var _17 : ();
  var _21 : ();
  var _22 : Core_Option_Option_Type.core_option_option_type t;
  var _23 : borrowed i;
  var _24 : isize;
  var i_25 : t;
  ghost var _26 : Seq.seq t;
  var _28 : ();
  var x_29 : t;
  var _30 : ();
  var _31 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _32 : t;
  var _33 : ();
  {
    v_1 <- v;
    i_2 <- i;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _7 <- ();
    old_v_4 <- ghost ([#"../04_extend.rs" 10 14 10 26] v_1);
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve old_v_4 };
    assume { Resolve1.resolve _9 };
    _9 <- i_2;
    i_2 <- any i;
    iter_8 <- ([#"../04_extend.rs" 11 2 11 42] IntoIter0.into_iter _9);
    goto BB3
  }
  BB3 {
    _13 <- ();
    iter_old_10 <- ghost ([#"../04_extend.rs" 11 2 11 42] iter_8);
    goto BB4
  }
  BB4 {
    assume { Resolve2.resolve iter_old_10 };
    _17 <- ();
    produced_14 <- ghost ([#"../04_extend.rs" 11 2 11 42] Seq.empty );
    goto BB5
  }
  BB5 {
    assume { Resolve3.resolve produced_14 };
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    invariant structural { [#"../04_extend.rs" 11 2 11 42] Produces0.produces iter_old_10 produced_14 iter_8 };
    invariant proph_const { [#"../04_extend.rs" 11 27 11 40]  ^ old_v_4 =  ^ v_1 };
    invariant x { [#"../04_extend.rs" 12 17 12 56] Seq.(==) (Model1.model v_1) (Seq.(++) (Model1.model old_v_4) produced_14) };
    _23 <- borrow_mut iter_8;
    iter_8 <-  ^ _23;
    _22 <- ([#"../04_extend.rs" 11 2 11 42] Next0.next _23);
    goto BB8
  }
  BB8 {
    switch (_22)
      | Core_Option_Option_Type.Core_Option_Option_None_Type -> goto BB9
      | Core_Option_Option_Type.Core_Option_Option_Some_Type _ -> goto BB11
      end
  }
  BB9 {
    assume { Resolve4.resolve v_1 };
    _0 <- ();
    goto BB17
  }
  BB10 {
    assume { Resolve4.resolve v_1 };
    assume { Resolve1.resolve iter_8 };
    assume { Resolve5.resolve _22 };
    absurd
  }
  BB11 {
    assume { Resolve6.resolve i_25 };
    i_25 <- Core_Option_Option_Type.core_option_option_type_Some_0 _22;
    _22 <- (let Core_Option_Option_Type.Core_Option_Option_Some_Type a = _22 in Core_Option_Option_Type.Core_Option_Option_Some_Type (any t));
    _28 <- ();
    _26 <- ghost ([#"../04_extend.rs" 11 2 11 42] Seq.snoc produced_14 i_25);
    goto BB12
  }
  BB12 {
    assume { Resolve3.resolve produced_14 };
    produced_14 <- _26;
    _26 <- any Seq.seq t;
    assume { Resolve6.resolve x_29 };
    x_29 <- i_25;
    i_25 <- any t;
    _31 <- borrow_mut ( * v_1);
    v_1 <- { v_1 with current = ( ^ _31) };
    assume { Resolve6.resolve _32 };
    _32 <- x_29;
    x_29 <- any t;
    _30 <- ([#"../04_extend.rs" 14 4 14 13] Push0.push _31 _32);
    goto BB13
  }
  BB13 {
    _21 <- ();
    goto BB14
  }
  BB14 {
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    assume { Resolve5.resolve _22 };
    goto BB7
  }
  BB17 {
    assume { Resolve5.resolve _22 };
    goto BB18
  }
  BB18 {
    assume { Resolve1.resolve iter_8 };
    goto BB19
  }
  BB19 {
    return _0
  }
  
end
module CreusotContracts_Std1_Vec_Impl3_Resolve_Interface
  type t
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))
end
module CreusotContracts_Std1_Vec_Impl3_Resolve
  type t
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve0 with type self = t
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  predicate resolve (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)) =
    forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model self) -> Resolve0.resolve (Seq.get (Model0.model self) i)
end
module Core_Mem_ManuallyDrop_ManuallyDrop_Type
  type core_mem_manuallydrop_manuallydrop_type 't =
    | Core_Mem_ManuallyDrop_ManuallyDrop_Type 't
    
end
module Alloc_Vec_IntoIter_IntoIter_Type
  use mach.int.Int
  use prelude.UIntSize
  use prelude.Opaque
  use Core_Mem_ManuallyDrop_ManuallyDrop_Type
  use Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type
  type alloc_vec_intoiter_intoiter_type 't 'a =
    | Alloc_Vec_IntoIter_IntoIter_Type (Core_Ptr_NonNull_NonNull_Type.core_ptr_nonnull_nonnull_type 't) (Core_Marker_PhantomData_Type.core_marker_phantomdata_type 't) usize (Core_Mem_ManuallyDrop_ManuallyDrop_Type.core_mem_manuallydrop_manuallydrop_type 'a) opaque_ptr opaque_ptr
    
end
module CreusotContracts_Std1_Vec_Impl2_Model_Interface
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  function model (self : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl2_Model
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  function model (self : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : Seq.seq t
end
module Alloc_Vec_Impl19_IntoIter_Interface
  type t
  type a
  use Alloc_Vec_IntoIter_IntoIter_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t, type a = a, axiom .
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  val into_iter [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a
    ensures { Model0.model result = Model1.model self }
    
end
module Alloc_Vec_Impl19_IntoIter
  type t
  type a
  use Alloc_Vec_IntoIter_IntoIter_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t, type a = a, axiom .
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  val into_iter [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a
    ensures { Model0.model result = Model1.model self }
    
end
module CreusotContracts_Std1_Vec_Impl3
  type t
end
module Alloc_Vec_Impl19
  type t
  type a
end
module CreusotContracts_Std1_Vec_Impl2
  type t
  type a
end
module CreusotContracts_Std1_Vec_Impl1_Produces_Interface
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  predicate produces (self : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (visited : Seq.seq t) (rhs : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a)
    
end
module CreusotContracts_Std1_Vec_Impl1_Produces
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  use mach.int.Int
  use seq_ext.SeqExt
  use mach.int.Int32
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  predicate produces (self : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (visited : Seq.seq t) (rhs : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a)
    
   =
    Seq.length (Model0.model self) = Seq.length visited + Seq.length (Model0.model rhs) /\ Seq.(==) (SeqExt.subsequence (Model0.model self) (Seq.length visited) (Seq.length (Model0.model self))) (Model0.model rhs) /\ (forall i : (int) . 0 <= i /\ i < Seq.length visited -> Seq.get (Model0.model self) i = Seq.get visited i)
end
module CreusotContracts_Std1_Vec_Impl1
  type t
  type a
end
module CreusotContracts_Std1_Vec_Impl1_Completed_Interface
  type t
  type a
  use Alloc_Vec_IntoIter_IntoIter_Type
  predicate completed (self : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a)
end
module CreusotContracts_Std1_Vec_Impl1_Completed
  type t
  type a
  use Alloc_Vec_IntoIter_IntoIter_Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  predicate completed (self : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) =
    Model0.model self = Seq.empty 
end
module CreusotContracts_Std1_Vec_Impl1_ProducesRefl_Interface
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_refl (a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : ()
end
module CreusotContracts_Std1_Vec_Impl1_ProducesRefl
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_refl (a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : () =
    ()
  axiom produces_refl_spec : forall a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a . Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Vec_Impl1_ProducesRefl_Impl
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl2_Model as Model0 with type t = t, type a = a
  clone CreusotContracts_Std1_Vec_Impl1_Produces as Produces0 with type t = t, type a = a,
  function Model0.model = Model0.model
  let rec ghost function produces_refl (a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : ()
    ensures { Produces0.produces a (Seq.empty ) a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    ()
end
module CreusotContracts_Std1_Vec_Impl1_ProducesTrans_Interface
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_trans (a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (ab : Seq.seq t) (b : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (bc : Seq.seq t) (c : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : ()
    
end
module CreusotContracts_Std1_Vec_Impl1_ProducesTrans
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_trans (a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (ab : Seq.seq t) (b : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (bc : Seq.seq t) (c : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : ()
    
   =
    ()
  axiom produces_trans_spec : forall a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a, ab : Seq.seq t, b : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a, bc : Seq.seq t, c : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a . Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Std1_Vec_Impl1_ProducesTrans_Impl
  type t
  type a
  use seq.Seq
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl2_Model as Model0 with type t = t, type a = a
  clone CreusotContracts_Std1_Vec_Impl1_Produces as Produces0 with type t = t, type a = a,
  function Model0.model = Model0.model
  let rec ghost function produces_trans (a : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (ab : Seq.seq t) (b : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) (bc : Seq.seq t) (c : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t a) : ()
    requires {Produces0.produces a ab b}
    requires {Produces0.produces b bc c}
    ensures { Produces0.produces a (Seq.(++) ab bc) c }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    ()
end
module C04Extend_Concat_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy_Type as ModelTy0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  val concat [@cfg:stackify] (v : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))) (w : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)) : ()
    ensures { [#"../04_extend.rs" 18 10 18 39] Seq.(==) (Model0.model ( ^ v)) (Seq.(++) (Model1.model v) (Model0.model w)) }
    
end
module C04Extend_Concat
  type t
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy_Type as ModelTy0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  use Alloc_Vec_IntoIter_IntoIter_Type
  clone CreusotContracts_Std1_Vec_Impl2_Model as Model2 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type
  clone CreusotContracts_Std1_Vec_Impl1_Produces as Produces0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_ProducesTrans as ProducesTrans0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, predicate Produces0.produces = Produces0.produces, axiom .
  clone CreusotContracts_Std1_Vec_Impl1_ProducesRefl as ProducesRefl0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, predicate Produces0.produces = Produces0.produces, axiom .
  clone CreusotContracts_Std1_Vec_Impl1_Completed as Completed0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = t
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve1 with type t = Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)
  clone C04Extend_Extend_Interface as Extend0 with type t = t,
  type i = Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type),
  predicate Produces0.produces = Produces0.produces, predicate Completed0.completed = Completed0.completed,
  function Model0.model = Model0.model, function Model1.model = Model1.model
  clone Alloc_Vec_Impl19_IntoIter_Interface as IntoIter0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model,
  function Model1.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve0 with type t = t, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  let rec cfg concat [@cfg:stackify] [#"../04_extend.rs" 19 0 19 39] (v : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))) (w : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)) : ()
    ensures { [#"../04_extend.rs" 18 10 18 39] Seq.(==) (Model0.model ( ^ v)) (Seq.(++) (Model1.model v) (Model0.model w)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var v_1 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var w_2 : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _4 : ();
  var _5 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _6 : Alloc_Vec_IntoIter_IntoIter_Type.alloc_vec_intoiter_intoiter_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _7 : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  {
    v_1 <- v;
    w_2 <- w;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _5 <- borrow_mut ( * v_1);
    v_1 <- { v_1 with current = ( ^ _5) };
    assume { Resolve0.resolve _7 };
    _7 <- w_2;
    w_2 <- any Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
    _6 <- ([#"../04_extend.rs" 20 12 20 25] IntoIter0.into_iter _7);
    goto BB2
  }
  BB2 {
    _4 <- ([#"../04_extend.rs" 20 2 20 26] Extend0.extend _5 _6);
    goto BB3
  }
  BB3 {
    assume { Resolve1.resolve v_1 };
    _0 <- ();
    goto BB4
  }
  BB4 {
    return _0
  }
  
end

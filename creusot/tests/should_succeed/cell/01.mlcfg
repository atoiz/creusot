
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 40 4 40 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module C01_Inv_Inv_Stub
  type self
  type t
  predicate inv [#"../01.rs" 8 4 8 25] (x : t)
end
module C01_Inv_Inv_Interface
  type self
  type t
  predicate inv [#"../01.rs" 8 4 8 25] (x : t)
  val inv [#"../01.rs" 8 4 8 25] (x : t) : bool
    ensures { result = inv x }
    
end
module C01_Inv_Inv
  type self
  type t
  predicate inv [#"../01.rs" 8 4 8 25] (x : t)
  val inv [#"../01.rs" 8 4 8 25] (x : t) : bool
    ensures { result = inv x }
    
end
module Core_Cell_UnsafeCell_Type
  type t_unsafecell 't =
    | C_UnsafeCell 't
    
end
module Core_Cell_Cell_Type
  use Core_Cell_UnsafeCell_Type as Core_Cell_UnsafeCell_Type
  type t_cell 't =
    | C_Cell (Core_Cell_UnsafeCell_Type.t_unsafecell 't)
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module C01_Cell_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Cell_Cell_Type as Core_Cell_Cell_Type
  type t_cell 't 'i =
    | C_Cell (Core_Cell_Cell_Type.t_cell 't) (Core_Marker_PhantomData_Type.t_phantomdata 'i)
    
  let function cell_inner (self : t_cell 't 'i) : Core_Cell_Cell_Type.t_cell 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Cell a _ -> a
      end
  let function cell_inv (self : t_cell 't 'i) : Core_Marker_PhantomData_Type.t_phantomdata 'i
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Cell _ a -> a
      end
end
module C01_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use C01_Cell_Type as C01_Cell_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t
  clone C01_Inv_Inv_Stub as Inv1 with
    type self = i,
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = C01_Cell_Type.t_cell t i
  val get [#"../01.rs" 19 4 19 26] (self : C01_Cell_Type.t_cell t i) : t
    requires {[#"../01.rs" 19 16 19 20] Inv0.inv self}
    ensures { [#"../01.rs" 18 14 18 28] Inv1.inv result }
    ensures { [#"../01.rs" 19 25 19 26] Inv2.inv result }
    
end
module C01_Impl0_Set_Interface
  type t
  type i
  use prelude.Borrow
  use C01_Cell_Type as C01_Cell_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = C01_Cell_Type.t_cell t i
  clone C01_Inv_Inv_Stub as Inv0 with
    type self = i,
    type t = t
  val set [#"../01.rs" 25 4 25 27] (self : C01_Cell_Type.t_cell t i) (v : t) : ()
    requires {[#"../01.rs" 24 15 24 24] Inv0.inv v}
    requires {[#"../01.rs" 25 16 25 20] Inv1.inv self}
    requires {[#"../01.rs" 25 22 25 23] Inv2.inv v}
    
end
module C01_Impl1_Inv_Stub
  use prelude.Int
  use prelude.UInt32
  predicate inv [#"../01.rs" 35 4 35 26] (x : uint32)
end
module C01_Impl1_Inv_Interface
  use prelude.Int
  use prelude.UInt32
  predicate inv [#"../01.rs" 35 4 35 26] (x : uint32)
  val inv [#"../01.rs" 35 4 35 26] (x : uint32) : bool
    ensures { result = inv x }
    
end
module C01_Impl1_Inv
  use prelude.Int
  use prelude.UInt32
  predicate inv [#"../01.rs" 35 4 35 26] (x : uint32) =
    [#"../01.rs" 36 8 36 24] mod x (2 : uint32) = (0 : uint32)
  val inv [#"../01.rs" 35 4 35 26] (x : uint32) : bool
    ensures { result = inv x }
    
end
module C01_Even_Type
  type t_even  =
    | C_Even
    
end
module CreusotContracts_Invariant_Invariant_Invariant_Stub
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant_Interface
  type self
  predicate invariant' (self : self)
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Invariant_Invariant
  type self
  predicate invariant' (self : self)
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module C01_Cell_Type_Inv
  type t
  type i
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Cell_Cell_Type as Core_Cell_Cell_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata i
  use C01_Cell_Type as C01_Cell_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Cell_Cell_Type.t_cell t
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = C01_Cell_Type.t_cell t i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = C01_Cell_Type.t_cell t i
  axiom inv_t_cell [@rewrite] : forall self : C01_Cell_Type.t_cell t i . Inv0.inv self = (Invariant0.invariant' self /\ Inv1.inv (C01_Cell_Type.cell_inner self) /\ Inv2.inv (C01_Cell_Type.cell_inv self))
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module CreusotContracts_Invariant_Impl0_Invariant_Stub
  type t
  predicate invariant' (self : t)
end
module CreusotContracts_Invariant_Impl0_Invariant_Interface
  type t
  predicate invariant' (self : t)
  val invariant' (self : t) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Impl0_Invariant
  type t
  predicate invariant' (self : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 21 8 21 12] true
  val invariant' (self : t) : bool
    ensures { result = invariant' self }
    
end
module Core_Cell_Cell_Type_Inv
  type t
  use Core_Cell_Cell_Type as Core_Cell_Cell_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Cell_Cell_Type.t_cell t
  axiom inv_t_cell : forall self : Core_Cell_Cell_Type.t_cell t . Inv0.inv self = true
end
module Core_Marker_PhantomData_Type_Inv
  type t
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = Core_Marker_PhantomData_Type.t_phantomdata t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata t
  axiom inv_t_phantomdata [@rewrite] : forall self : Core_Marker_PhantomData_Type.t_phantomdata t . Inv0.inv self = Invariant0.invariant' self
end
module CreusotContracts_Invariant_Impl0_IsInhabited_Stub
  type t
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function is_inhabited (_1 : ()) : bool
end
module CreusotContracts_Invariant_Impl0_IsInhabited_Interface
  type t
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function is_inhabited (_1 : ()) : bool
  val is_inhabited (_1 : ()) : bool
    ensures { [#"../../../../../creusot-contracts/src/invariant.rs" 26 4 26 45] exists x : t . Inv0.inv x /\ Invariant0.invariant' x }
    ensures { [#"../../../../../creusot-contracts/src/invariant.rs" 27 14 27 20] result }
    ensures { result = is_inhabited _1 }
    
  axiom is_inhabited_spec : forall _1 : () . ([#"../../../../../creusot-contracts/src/invariant.rs" 27 14 27 20] is_inhabited _1) && ([#"../../../../../creusot-contracts/src/invariant.rs" 26 4 26 45] exists x : t . Inv0.inv x /\ Invariant0.invariant' x)
end
module CreusotContracts_Invariant_Impl0_IsInhabited
  type t
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function is_inhabited (_1 : ()) : bool =
    [#"../../../../../creusot-contracts/src/invariant.rs" 32 8 32 12] true
  val is_inhabited (_1 : ()) : bool
    ensures { [#"../../../../../creusot-contracts/src/invariant.rs" 26 4 26 45] exists x : t . Inv0.inv x /\ Invariant0.invariant' x }
    ensures { [#"../../../../../creusot-contracts/src/invariant.rs" 27 14 27 20] result }
    ensures { result = is_inhabited _1 }
    
  axiom is_inhabited_spec : forall _1 : () . ([#"../../../../../creusot-contracts/src/invariant.rs" 27 14 27 20] is_inhabited _1) && ([#"../../../../../creusot-contracts/src/invariant.rs" 26 4 26 45] exists x : t . Inv0.inv x /\ Invariant0.invariant' x)
end
module C01_AddsTwo_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  use C01_Even_Type as C01_Even_Type
  use C01_Cell_Type as C01_Cell_Type
  val adds_two [#"../01.rs" 40 0 40 36] (c : C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even)) : ()
end
module C01_AddsTwo
  use prelude.Int
  use prelude.UInt32
  use prelude.Borrow
  use C01_Even_Type as C01_Even_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  clone CreusotContracts_Invariant_Impl0_Invariant as Invariant1 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (C01_Even_Type.t_even)
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (C01_Even_Type.t_even)
  clone CreusotContracts_Invariant_Impl0_IsInhabited as IsInhabited1 with
    type t = Core_Marker_PhantomData_Type.t_phantomdata (C01_Even_Type.t_even),
    predicate Inv0.inv = Inv5.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    axiom .
  clone Core_Marker_PhantomData_Type_Inv as Core_Marker_PhantomData_Type_Inv0 with
    type t = C01_Even_Type.t_even,
    predicate Inv0.inv = Inv5.inv,
    predicate Invariant0.invariant' = Invariant1.invariant',
    axiom .
  use Core_Cell_Cell_Type as Core_Cell_Cell_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Cell_Cell_Type.t_cell uint32
  clone Core_Cell_Cell_Type_Inv as Core_Cell_Cell_Type_Inv0 with
    type t = uint32,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use C01_Cell_Type as C01_Cell_Type
  clone CreusotContracts_Invariant_Impl0_Invariant as Invariant0 with
    type t = C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even)
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even)
  clone CreusotContracts_Invariant_Impl0_IsInhabited as IsInhabited0 with
    type t = C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even),
    predicate Inv0.inv = Inv3.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone C01_Cell_Type_Inv as C01_Cell_Type_Inv1 with
    type t = uint32,
    type i = C01_Even_Type.t_even,
    predicate Inv0.inv = Inv3.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = uint32
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = uint32,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone C01_Cell_Type_Inv as C01_Cell_Type_Inv0 with
    type t = uint32,
    type i = C01_Even_Type.t_even,
    predicate Inv0.inv = Inv3.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv5.inv,
    axiom .
  clone C01_Impl1_Inv as Inv1
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even)
  clone C01_Impl0_Set_Interface as Set0 with
    type t = uint32,
    type i = C01_Even_Type.t_even,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    predicate Inv2.inv = Inv2.inv
  clone C01_Impl0_Get_Interface as Get0 with
    type t = uint32,
    type i = C01_Even_Type.t_even,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv2.inv
  let rec cfg adds_two [#"../01.rs" 40 0 40 36] [@cfg:stackify] [@cfg:subregion_analysis] (c : C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even)) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var c : C01_Cell_Type.t_cell uint32 (C01_Even_Type.t_even) = c;
  var v : uint32;
  var _6 : ();
  var _10 : ();
  {
    goto BB0
  }
  BB0 {
    v <- ([#"../01.rs" 41 12 41 19] Get0.get c);
    goto BB1
  }
  BB1 {
    switch ([#"../01.rs" 43 7 43 17] v < ([#"../01.rs" 43 11 43 17] (100000 : uint32)))
      | False -> goto BB4
      | True -> goto BB2
      end
  }
  BB2 {
    _6 <- ([#"../01.rs" 44 8 44 20] Set0.set c ([#"../01.rs" 44 14 44 19] v + ([#"../01.rs" 44 18 44 19] (2 : uint32))));
    goto BB3
  }
  BB3 {
    _0 <- ();
    goto BB6
  }
  BB4 {
    _10 <- ([#"../01.rs" 46 8 46 16] Set0.set c ([#"../01.rs" 46 14 46 15] (0 : uint32)));
    goto BB5
  }
  BB5 {
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module C01_Impl1
  
end

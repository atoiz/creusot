
module Generated_Sum10_Type
  use prelude.Int
  use prelude.Int32
  type t_sum10  =
    | C_Sum10 int32 int32
    
  let function sum10_0 (self : t_sum10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Sum10 a _ -> a
      end
  let function sum10_1 (self : t_sum10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Sum10 _ a -> a
      end
end
module Generated_Impl0_Invariant_Stub
  use Generated_Sum10_Type as Generated_Sum10_Type
  predicate invariant' [#"../generated.rs" 12 4 12 30] (self : Generated_Sum10_Type.t_sum10)
end
module Generated_Impl0_Invariant_Interface
  use Generated_Sum10_Type as Generated_Sum10_Type
  predicate invariant' [#"../generated.rs" 12 4 12 30] (self : Generated_Sum10_Type.t_sum10)
  val invariant' [#"../generated.rs" 12 4 12 30] (self : Generated_Sum10_Type.t_sum10) : bool
    ensures { result = invariant' self }
    
end
module Generated_Impl0_Invariant
  use prelude.Int32
  use prelude.Int
  use Generated_Sum10_Type as Generated_Sum10_Type
  predicate invariant' [#"../generated.rs" 12 4 12 30] (self : Generated_Sum10_Type.t_sum10) =
    [#"../generated.rs" 13 20 13 43] Int32.to_int (Generated_Sum10_Type.sum10_0 self) + Int32.to_int (Generated_Sum10_Type.sum10_1 self) = 10
  val invariant' [#"../generated.rs" 12 4 12 30] (self : Generated_Sum10_Type.t_sum10) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 27 4 27 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Generated_Foo_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Generated_Sum10_Type as Generated_Sum10_Type
  type t_foo 't =
    | C_A (borrowed (Generated_Sum10_Type.t_sum10)) usize
    | C_B 't
    
  let function a_f1 (self : t_foo 't) : borrowed (Generated_Sum10_Type.t_sum10) = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_A a _ -> a
      | C_B _ -> any borrowed (Generated_Sum10_Type.t_sum10)
      end
  let function b_0 (self : t_foo 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_A _ _ -> any 't
      | C_B a -> a
      end
end
module Generated_Foo_Type_Inv
  type t
  use prelude.Borrow
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t
  use Generated_Foo_Type as Generated_Foo_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Generated_Sum10_Type.t_sum10
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Generated_Foo_Type.t_foo t
  axiom inv_t_foo [@rewrite] : forall self : Generated_Foo_Type.t_foo t . Inv0.inv self = match (self) with
    | Generated_Foo_Type.C_A f1 _ -> Inv1.inv ( * Generated_Foo_Type.a_f1 self) /\ Inv1.inv ( ^ Generated_Foo_Type.a_f1 self)
    | Generated_Foo_Type.C_B a_0 -> Inv2.inv (Generated_Foo_Type.b_0 self)
    end
end
module Generated_Sum10_Type_Inv
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone Generated_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Generated_Sum10_Type.t_sum10
  axiom inv_t_sum10 [@rewrite] : forall self : Generated_Sum10_Type.t_sum10 . Inv0.inv self = Invariant0.invariant' self
end
module TyInv_Tuple2
  type t0
  type t1
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t1
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (t0, t1)
  axiom inv_tuple2 [@rewrite] : forall self : (t0, t1) . Inv0.inv self = (let (a_0, a_1) = self in Inv1.inv a_0 /\ Inv2.inv a_1)
end
module TyInv_Borrow
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  axiom inv_borrow [@rewrite] : forall self : borrowed t . Inv0.inv self = (Inv1.inv ( * self) /\ Inv1.inv ( ^ self))
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module Generated_UseFoo_Interface
  use prelude.Int
  use prelude.UInt32
  use prelude.Borrow
  use Generated_Sum10_Type as Generated_Sum10_Type
  use Generated_Foo_Type as Generated_Foo_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Generated_Foo_Type.t_foo (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10))
  val use_foo [#"../generated.rs" 22 0 22 61] (x : Generated_Foo_Type.t_foo (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10))) : ()
    requires {[#"../generated.rs" 22 19 22 20] Inv0.inv x}
    
end
module Generated_UseFoo
  use prelude.Int
  use prelude.UInt32
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = uint32
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = uint32,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Generated_Sum10_Type.t_sum10
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Generated_Sum10_Type.t_sum10)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Generated_Sum10_Type.t_sum10,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use Generated_Foo_Type as Generated_Foo_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Generated_Foo_Type.t_foo uint32
  clone Generated_Foo_Type_Inv as Generated_Foo_Type_Inv1 with
    type t = uint32,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv5.inv,
    axiom .
  clone Generated_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10))
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = Generated_Foo_Type.t_foo uint32,
    type t1 = borrowed (Generated_Sum10_Type.t_sum10),
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone Generated_Sum10_Type_Inv as Generated_Sum10_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Generated_Foo_Type.t_foo (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10))
  clone Generated_Foo_Type_Inv as Generated_Foo_Type_Inv0 with
    type t = (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10)),
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv2.inv,
    axiom .
  let rec cfg use_foo [#"../generated.rs" 22 0 22 61] [@cfg:stackify] [@cfg:subregion_analysis] (x : Generated_Foo_Type.t_foo (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10))) : ()
    requires {[#"../generated.rs" 22 19 22 20] Inv0.inv x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : Generated_Foo_Type.t_foo (Generated_Foo_Type.t_foo uint32, borrowed (Generated_Sum10_Type.t_sum10)) = x;
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:assertion] [#"../generated.rs" 23 18 23 35] Inv0.inv x };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Std1_Ops_FnOnceExt_Precondition_Stub
  type self
  type args
  predicate precondition (self : self) (a : args)
end
module CreusotContracts_Std1_Ops_FnOnceExt_Precondition_Interface
  type self
  type args
  predicate precondition (self : self) (a : args)
  val precondition (self : self) (a : args) : bool
    ensures { result = precondition self a }
    
end
module CreusotContracts_Std1_Ops_FnOnceExt_Precondition
  type self
  type args
  predicate precondition (self : self) (a : args)
  val precondition (self : self) (a : args) : bool
    ensures { result = precondition self a }
    
end
module Core_Ops_Function_FnOnce_Output_Type
  type self
  type args
  type output
end
module CreusotContracts_Std1_Ops_FnOnceExt_PostconditionOnce_Stub
  type self
  type args
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  predicate postcondition_once (self : self) (a : args) (res : Output0.output)
end
module CreusotContracts_Std1_Ops_FnOnceExt_PostconditionOnce_Interface
  type self
  type args
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  predicate postcondition_once (self : self) (a : args) (res : Output0.output)
  val postcondition_once (self : self) (a : args) (res : Output0.output) : bool
    ensures { result = postcondition_once self a res }
    
end
module CreusotContracts_Std1_Ops_FnOnceExt_PostconditionOnce
  type self
  type args
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  predicate postcondition_once (self : self) (a : args) (res : Output0.output)
  val postcondition_once (self : self) (a : args) (res : Output0.output) : bool
    ensures { result = postcondition_once self a res }
    
end
module Core_Ops_Function_FnOnce_CallOnce_Interface
  type self
  type args
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = self,
    type args = args
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Ops_FnOnceExt_PostconditionOnce_Stub as PostconditionOnce0 with
    type self = self,
    type args = args,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = args
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  clone CreusotContracts_Std1_Ops_FnOnceExt_Precondition_Stub as Precondition0 with
    type self = self,
    type args = args
  val call_once (self : self) (args : args) : Output0.output
    requires {[#"../../../../../creusot-contracts/src/std/ops.rs" 148 0 172 1] Precondition0.precondition self args}
    requires {Inv0.inv self}
    requires {Inv1.inv args}
    ensures { [#"../../../../../creusot-contracts/src/std/ops.rs" 148 0 172 1] PostconditionOnce0.postcondition_once self args result }
    ensures { Inv2.inv result }
    
end
module CreusotContracts_Std1_Ops_Impl0_Precondition_Stub
  type args
  type f
  predicate precondition (self : f) (_2 : args)
end
module CreusotContracts_Std1_Ops_Impl0_Precondition_Interface
  type args
  type f
  predicate precondition (self : f) (_2 : args)
  val precondition (self : f) (_2 : args) : bool
    ensures { result = precondition self _2 }
    
end
module CreusotContracts_Std1_Ops_Impl0_Precondition
  type args
  type f
  predicate precondition (self : f) (_2 : args)
  val precondition (self : f) (_2 : args) : bool
    ensures { result = precondition self _2 }
    
end
module CreusotContracts_Std1_Ops_Impl0_PostconditionOnce_Stub
  type args
  type f
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = f,
    type args = args
  predicate postcondition_once (self : f) (_2 : args) (_3 : Output0.output)
end
module CreusotContracts_Std1_Ops_Impl0_PostconditionOnce_Interface
  type args
  type f
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = f,
    type args = args
  predicate postcondition_once (self : f) (_2 : args) (_3 : Output0.output)
  val postcondition_once (self : f) (_2 : args) (_3 : Output0.output) : bool
    ensures { result = postcondition_once self _2 _3 }
    
end
module CreusotContracts_Std1_Ops_Impl0_PostconditionOnce
  type args
  type f
  clone Core_Ops_Function_FnOnce_Output_Type as Output0 with
    type self = f,
    type args = args
  predicate postcondition_once (self : f) (_2 : args) (_3 : Output0.output)
  val postcondition_once (self : f) (_2 : args) (_3 : Output0.output) : bool
    ensures { result = postcondition_once self _2 _3 }
    
end
module Generated_TakeClosure_Interface
  type t
  type f
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = f
  val take_closure [#"../generated.rs" 26 0 26 51] (f : f) : t
    requires {[#"../generated.rs" 26 41 26 42] Inv0.inv f}
    ensures { [#"../generated.rs" 26 50 26 51] Inv1.inv result }
    
end
module Generated_TakeClosure
  type t
  type f
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = ()
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = (),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = f
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = f,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Std1_Ops_Impl0_PostconditionOnce_Interface as PostconditionOnce0 with
    type args = (),
    type f = f,
    type Output0.output = t
  clone CreusotContracts_Std1_Ops_Impl0_Precondition_Interface as Precondition0 with
    type args = (),
    type f = f
  clone Core_Ops_Function_FnOnce_CallOnce_Interface as CallOnce0 with
    type self = f,
    type args = (),
    predicate Precondition0.precondition = Precondition0.precondition,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate PostconditionOnce0.postcondition_once = PostconditionOnce0.postcondition_once,
    predicate Inv2.inv = Inv1.inv,
    type Output0.output = t
  let rec cfg take_closure [#"../generated.rs" 26 0 26 51] [@cfg:stackify] [@cfg:subregion_analysis] (f : f) : t
    requires {[#"../generated.rs" 26 41 26 42] Inv0.inv f}
    ensures { [#"../generated.rs" 26 50 26 51] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var f : f = f;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../generated.rs" 27 4 27 7] CallOnce0.call_once f ());
    f <- any f;
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 36 8 36 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module Generated_TestClosure_Closure0_Type
  use Generated_Sum10_Type as Generated_Sum10_Type
  type generated_testclosure_closure0  =
    | Generated_TestClosure_Closure0 (Generated_Sum10_Type.t_sum10)
    
end
module Generated_TestClosure_Closure0_Interface
  use export Generated_TestClosure_Closure0_Type
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Generated_Sum10_Type.t_sum10
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = generated_testclosure_closure0
  let function field_0 [#"../generated.rs" 32 12 32 19] (self : generated_testclosure_closure0) : Generated_Sum10_Type.t_sum10
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../generated.rs" 1 0 1 0] let Generated_TestClosure_Closure0 a = self in a
  predicate resolve [#"../generated.rs" 32 12 32 19] (_1 : generated_testclosure_closure0) =
    [#"../generated.rs" 1 0 1 0] true
  predicate precondition [#"../generated.rs" 32 12 32 19] (self : generated_testclosure_closure0) (_ : ()) =
    [#"../generated.rs" 1 0 1 0] true
  predicate postcondition_once [#"../generated.rs" 32 12 32 19] (self : generated_testclosure_closure0) (_ : ()) (result : Generated_Sum10_Type.t_sum10)
    
   =
    [#"../generated.rs" 1 0 1 0] true
  val generated_TestClosure_Closure0 [#"../generated.rs" 32 12 32 19] (_1 : generated_testclosure_closure0) : Generated_Sum10_Type.t_sum10
    requires {[#"../generated.rs" 1 0 1 0] Inv0.inv _1}
    ensures { [#"../generated.rs" 32 12 32 19] Inv1.inv result }
    
end
module Generated_TestClosure_Closure0
  use export Generated_TestClosure_Closure0_Type
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone Generated_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Generated_Sum10_Type.t_sum10
  clone Generated_Sum10_Type_Inv as Generated_Sum10_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = generated_testclosure_closure0
  let function field_0 [#"../generated.rs" 32 12 32 19] (self : generated_testclosure_closure0) : Generated_Sum10_Type.t_sum10
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../generated.rs" 1 0 1 0] let Generated_TestClosure_Closure0 a = self in a
  predicate resolve [#"../generated.rs" 32 12 32 19] (_1 : generated_testclosure_closure0) =
    [#"../generated.rs" 1 0 1 0] true
  predicate precondition [#"../generated.rs" 32 12 32 19] (self : generated_testclosure_closure0) (_ : ()) =
    [#"../generated.rs" 1 0 1 0] true
  predicate postcondition_once [#"../generated.rs" 32 12 32 19] (self : generated_testclosure_closure0) (_ : ()) (result : Generated_Sum10_Type.t_sum10)
    
   =
    [#"../generated.rs" 1 0 1 0] true
  let rec cfg generated_TestClosure_Closure0 [#"../generated.rs" 32 12 32 19] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : generated_testclosure_closure0) : Generated_Sum10_Type.t_sum10
    requires {[#"../generated.rs" 1 0 1 0] Inv0.inv _1}
    ensures { [#"../generated.rs" 32 12 32 19] Inv1.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Generated_Sum10_Type.t_sum10;
  var _1 : generated_testclosure_closure0 = _1;
  {
    goto BB0
  }
  BB0 {
    _0 <- field_0 _1;
    _1 <- (let Generated_TestClosure_Closure0 a = _1 in Generated_TestClosure_Closure0 (any Generated_Sum10_Type.t_sum10));
    assert { [@expl:type invariant] Inv0.inv _1 };
    assume { resolve _1 };
    return _0
  }
  
end
module Generated_TestClosure_Closure0_Inv
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Generated_Sum10_Type.t_sum10
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Closure00.generated_testclosure_closure0
  clone Generated_TestClosure_Closure0_Interface as Closure00 with
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  axiom inv_generated_testclosure_closure0 [@rewrite] : forall self : Closure00.generated_testclosure_closure0 . Inv0.inv self = Inv1.inv (Closure00.field_0 self)
end
module Generated_TestClosure_Interface
  val test_closure [#"../generated.rs" 30 0 30 21] (_1 : ()) : ()
end
module Generated_TestClosure
  use prelude.Int
  use prelude.Int32
  use Generated_Sum10_Type as Generated_Sum10_Type
  clone Generated_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Generated_Sum10_Type.t_sum10
  clone Generated_Sum10_Type_Inv as Generated_Sum10_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Closure00.generated_testclosure_closure0
  clone Generated_TestClosure_Closure0_Interface as Closure00 with
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Generated_TestClosure_Closure0_Inv as Generated_TestClosure_Closure0_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Generated_TakeClosure_Interface as TakeClosure0 with
    type t = Generated_Sum10_Type.t_sum10,
    type f = Closure00.generated_testclosure_closure0,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  let rec cfg test_closure [#"../generated.rs" 30 0 30 21] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : Generated_Sum10_Type.t_sum10;
  var c : Closure00.generated_testclosure_closure0;
  var _3 : Generated_Sum10_Type.t_sum10;
  {
    goto BB0
  }
  BB0 {
    x <- Generated_Sum10_Type.C_Sum10 ([#"../generated.rs" 31 18 31 19] (3 : int32)) ([#"../generated.rs" 31 21 31 22] (7 : int32));
    c <- Closure00.Generated_TestClosure_Closure0 x;
    x <- any Generated_Sum10_Type.t_sum10;
    _3 <- ([#"../generated.rs" 33 4 33 19] TakeClosure0.take_closure c);
    c <- any Closure00.generated_testclosure_closure0;
    goto BB1
  }
  BB1 {
    _0 <- ();
    return _0
  }
  
end
module Generated_Impl0
  
end

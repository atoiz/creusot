
module Borrows_NonZero_Type
  use prelude.Int
  use prelude.Int32
  type t_nonzero  =
    | C_NonZero int32
    
  let function nonzero_0 (self : t_nonzero) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_NonZero a -> a
      end
end
module Borrows_Impl0_Invariant_Stub
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant' [#"../borrows.rs" 8 4 8 30] (self : Borrows_NonZero_Type.t_nonzero)
end
module Borrows_Impl0_Invariant_Interface
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant' [#"../borrows.rs" 8 4 8 30] (self : Borrows_NonZero_Type.t_nonzero)
end
module Borrows_Impl0_Invariant
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant' [#"../borrows.rs" 8 4 8 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 9 20 9 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant' [#"../borrows.rs" 8 4 8 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant' self }
    
end
module Borrows_Impl1_New_Interface
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant_Stub as Invariant0
  val new [#"../borrows.rs" 16 4 16 30] (n : int32) : Borrows_NonZero_Type.t_nonzero
    requires {[#"../borrows.rs" 14 15 14 22] Int32.to_int n <> 0}
    ensures { [#"../borrows.rs" 15 14 15 27] Borrows_NonZero_Type.nonzero_0 result = n }
    ensures { [#"../borrows.rs" 16 26 16 30] Invariant0.invariant' result }
    
end
module Borrows_Impl1_New
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  let rec cfg new [#"../borrows.rs" 16 4 16 30] [@cfg:stackify] [@cfg:subregion_analysis] (n : int32) : Borrows_NonZero_Type.t_nonzero
    requires {[#"../borrows.rs" 14 15 14 22] Int32.to_int n <> 0}
    ensures { [#"../borrows.rs" 15 14 15 27] Borrows_NonZero_Type.nonzero_0 result = n }
    ensures { [#"../borrows.rs" 16 26 16 30] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Borrows_NonZero_Type.t_nonzero;
  var n_1 : int32;
  var _4 : int32;
  {
    n_1 <- n;
    goto BB0
  }
  BB0 {
    _4 <- n_1;
    _0 <- Borrows_NonZero_Type.C_NonZero _4;
    return _0
  }
  
end
module CreusotContracts_Invariant_Invariant_Invariant_Stub
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant_Interface
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant
  type self
  predicate invariant' (self : self) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Impl1_Invariant_Stub
  type t
  use prelude.Borrow
  predicate invariant' (self : borrowed t)
end
module CreusotContracts_Invariant_Impl1_Invariant_Interface
  type t
  use prelude.Borrow
  predicate invariant' (self : borrowed t)
end
module CreusotContracts_Invariant_Impl1_Invariant
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  predicate invariant' (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 34 20 34 62] Invariant0.invariant' ( * self) /\ Invariant0.invariant' ( ^ self)
  val invariant' (self : borrowed t) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 23 20 23 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Borrows_Impl1_InnerMut_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero
  val inner_mut [#"../borrows.rs" 22 4 22 43] (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : borrowed int32
    requires {[#"../borrows.rs" 22 26 22 30] Invariant0.invariant' self}
    ensures { [#"../borrows.rs" 20 14 20 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * self)) = Int32.to_int ( * result) }
    ensures { [#"../borrows.rs" 21 14 21 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( ^ self)) = Int32.to_int ( ^ result) }
    
end
module Borrows_Impl1_InnerMut
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant1
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg inner_mut [#"../borrows.rs" 22 4 22 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : borrowed int32
    requires {[#"../borrows.rs" 22 26 22 30] Invariant0.invariant' self}
    ensures { [#"../borrows.rs" 20 14 20 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * self)) = Int32.to_int ( * result) }
    ensures { [#"../borrows.rs" 21 14 21 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( ^ self)) = Int32.to_int ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var self_1 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _2 : borrowed int32;
  var _5 : borrowed int32;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * self_1));
    self_1 <- { self_1 with current = (let Borrows_NonZero_Type.C_NonZero a =  * self_1 in Borrows_NonZero_Type.C_NonZero ( ^ _5)) };
    _2 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _2) };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve0.resolve _5 };
    assume { Resolve0.resolve _2 };
    assert { Invariant0.invariant' self_1 };
    assume { Resolve1.resolve self_1 };
    return _0
  }
  
end
module Core_Num_Impl2_Max_Stub
  use prelude.Int
  use prelude.Int32
  val constant mAX'  : int32
end
module Core_Num_Impl2_Max
  use prelude.Int
  use prelude.Int32
  let constant mAX'  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../../creusot-contracts/src/model.rs" 54 8 54 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Num_Impl24_ShallowModel_Stub
  use prelude.Int
  use prelude.Int32
  function shallow_model (self : int32) : int
end
module CreusotContracts_Std1_Num_Impl24_ShallowModel_Interface
  use prelude.Int
  use prelude.Int32
  function shallow_model (self : int32) : int
end
module CreusotContracts_Std1_Num_Impl24_ShallowModel
  use prelude.Int
  use prelude.Int32
  function shallow_model (self : int32) : int =
    Int32.to_int self
  val shallow_model (self : int32) : int
    ensures { result = shallow_model self }
    
end
module Borrows_Inc_Interface
  use prelude.Int32
  use prelude.Int
  use prelude.Borrow
  use prelude.Int
  clone Core_Num_Impl2_Max_Stub as Max0
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int
  val inc [#"../borrows.rs" 98 0 98 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 96 11 96 25] ShallowModel0.shallow_model x < Int32.to_int Max0.mAX'}
    ensures { [#"../borrows.rs" 97 10 97 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x + 1 }
    
end
module Borrows_Inc
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg inc [#"../borrows.rs" 98 0 98 23] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 96 11 96 25] ShallowModel0.shallow_model x < Int32.to_int Max0.mAX'}
    ensures { [#"../borrows.rs" 97 10 97 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x + 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    x_1 <- { x_1 with current = ([#"../borrows.rs" 99 4 99 11]  * x_1 + ([#"../borrows.rs" 99 10 99 11] (1 : int32))) };
    assume { Resolve0.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Simple_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Core_Num_Impl2_Max_Stub as Max0
  val simple [#"../borrows.rs" 30 0 30 30] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 28 11 28 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 29 11 29 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 30 14 30 15] Invariant0.invariant' x}
    
end
module Borrows_Simple
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant1
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg simple [#"../borrows.rs" 30 0 30 30] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 28 11 28 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 29 11 29 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 30 14 30 15] Invariant0.invariant' x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _6 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * x_1));
    x_1 <- { x_1 with current = (let Borrows_NonZero_Type.C_NonZero a =  * x_1 in Borrows_NonZero_Type.C_NonZero ( ^ _6)) };
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    _4 <- ([#"../borrows.rs" 31 4 31 17] Inc0.inc _5);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _6 };
    assert { Invariant0.invariant' x_1 };
    assume { Resolve1.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Hard_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Core_Num_Impl2_Max_Stub as Max0
  val hard [#"../borrows.rs" 37 0 37 28] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 35 11 35 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 36 11 36 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 37 12 37 13] Invariant0.invariant' x}
    
end
module Borrows_Hard
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Borrows_Impl0_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant1.invariant'
  clone Borrows_Impl1_InnerMut_Interface as InnerMut0 with
    predicate Invariant0.invariant' = Invariant0.invariant'
  let rec cfg hard [#"../borrows.rs" 37 0 37 28] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 35 11 35 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 36 11 36 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 37 12 37 13] Invariant0.invariant' x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  var _7 : borrowed (Borrows_NonZero_Type.t_nonzero);
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    _7 <- borrow_mut ( * x_1);
    x_1 <- { x_1 with current = ( ^ _7) };
    assume { Invariant1.invariant' ( ^ _7) };
    _6 <- ([#"../borrows.rs" 38 8 38 21] InnerMut0.inner_mut _7);
    goto BB1
  }
  BB1 {
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    _4 <- ([#"../borrows.rs" 38 4 38 22] Inc0.inc _5);
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve _6 };
    assert { Invariant0.invariant' x_1 };
    assume { Resolve1.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Invariant_Impl3_Invariant_Stub
  type t
  type u
  predicate invariant' (self : (t, u))
end
module CreusotContracts_Invariant_Impl3_Invariant_Interface
  type t
  type u
  predicate invariant' (self : (t, u))
end
module CreusotContracts_Invariant_Impl3_Invariant
  type t
  type u
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant1 with
    type self = u
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  predicate invariant' (self : (t, u)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 50 8 50 62] Invariant0.invariant' (let (a, _) = self in a) /\ Invariant1.invariant' (let (_, a) = self in a)
  val invariant' (self : (t, u)) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 15 8 15 60] Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 33 8 33 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module Borrows_Tuple_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl3_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    type u = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone Core_Num_Impl2_Max_Stub as Max0
  val tuple [#"../borrows.rs" 44 0 44 44] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 42 11 42 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 43 11 43 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 44 17 44 18] Invariant0.invariant' x}
    
end
module Borrows_Tuple
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = Borrows_NonZero_Type.t_nonzero
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Borrows_Impl0_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant2 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant1.invariant'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve1 with
    type t1 = Borrows_NonZero_Type.t_nonzero,
    type t2 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Impl3_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    type u = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  let rec cfg tuple [#"../borrows.rs" 44 0 44 44] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 42 11 42 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 43 11 43 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 44 17 44 18] Invariant0.invariant' x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero));
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    x_1 <- (let (a, b) = x_1 in (let Borrows_NonZero_Type.C_NonZero a = let (a, _) = x_1 in a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 45 12 45 13] (0 : int32)), b));
    _6 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x_1 in a)));
    x_1 <- (let (a, b) = x_1 in (a, { (let (_, a) = x_1 in a) with current = (let Borrows_NonZero_Type.C_NonZero a =  * (let (_, a) = x_1 in a) in Borrows_NonZero_Type.C_NonZero ( ^ _6)) }));
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    _4 <- ([#"../borrows.rs" 46 4 46 19] Inc0.inc _5);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _6 };
    assert { Invariant0.invariant' x_1 };
    assume { Resolve1.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Borrows_PartialMove_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl3_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    type u = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone Core_Num_Impl2_Max_Stub as Max0
  val partial_move [#"../borrows.rs" 52 0 52 47] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 50 11 50 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 51 11 51 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 52 20 52 21] Invariant0.invariant' x}
    
end
module Borrows_PartialMove
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = Borrows_NonZero_Type.t_nonzero
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Borrows_Impl0_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant2 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant1.invariant'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve1 with
    type t1 = Borrows_NonZero_Type.t_nonzero,
    type t2 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Impl3_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    type u = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  let rec cfg partial_move [#"../borrows.rs" 52 0 52 47] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 50 11 50 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 51 11 51 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 52 20 52 21] Invariant0.invariant' x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero));
  var a_4 : Borrows_NonZero_Type.t_nonzero;
  var _5 : ();
  var _6 : borrowed int32;
  var _7 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    a_4 <- (let (a, _) = x_1 in a);
    x_1 <- (let (a, b) = x_1 in (any Borrows_NonZero_Type.t_nonzero, b));
    _7 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x_1 in a)));
    x_1 <- (let (a, b) = x_1 in (a, { (let (_, a) = x_1 in a) with current = (let Borrows_NonZero_Type.C_NonZero a =  * (let (_, a) = x_1 in a) in Borrows_NonZero_Type.C_NonZero ( ^ _7)) }));
    _6 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _6) };
    _5 <- ([#"../borrows.rs" 54 4 54 19] Inc0.inc _6);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    assert { Invariant0.invariant' x_1 };
    assume { Resolve1.resolve x_1 };
    a_4 <- (let Borrows_NonZero_Type.C_NonZero a = a_4 in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 55 10 55 11] (0 : int32)));
    _0 <- ();
    return _0
  }
  
end
module Borrows_Destruct_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl3_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    type u = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone Core_Num_Impl2_Max_Stub as Max0
  val destruct [#"../borrows.rs" 60 0 60 43] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 58 11 58 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 59 11 59 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 60 16 60 17] Invariant0.invariant' x}
    
end
module Borrows_Destruct
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve3 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Borrows_Impl0_Invariant as Invariant2
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant1 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = Borrows_NonZero_Type.t_nonzero,
    type t2 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone CreusotContracts_Invariant_Impl3_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    type u = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant1.invariant'
  let rec cfg destruct [#"../borrows.rs" 60 0 60 43] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 58 11 58 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 59 11 59 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 60 16 60 17] Invariant0.invariant' x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero));
  var a_4 : Borrows_NonZero_Type.t_nonzero;
  var b_5 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _6 : ();
  var _7 : borrowed int32;
  var _8 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    a_4 <- (let (a, _) = x_1 in a);
    x_1 <- (let (a, b) = x_1 in (any Borrows_NonZero_Type.t_nonzero, b));
    b_5 <- (let (_, a) = x_1 in a);
    x_1 <- (let (a, b) = x_1 in (a, any borrowed (Borrows_NonZero_Type.t_nonzero)));
    assert { Invariant0.invariant' x_1 };
    assume { Resolve0.resolve x_1 };
    a_4 <- (let Borrows_NonZero_Type.C_NonZero a = a_4 in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 62 10 62 11] (0 : int32)));
    _8 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * b_5));
    b_5 <- { b_5 with current = (let Borrows_NonZero_Type.C_NonZero a =  * b_5 in Borrows_NonZero_Type.C_NonZero ( ^ _8)) };
    _7 <- borrow_mut ( * _8);
    _8 <- { _8 with current = ( ^ _7) };
    _6 <- ([#"../borrows.rs" 63 4 63 17] Inc0.inc _7);
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve _8 };
    assert { Invariant1.invariant' b_5 };
    assume { Resolve2.resolve b_5 };
    _0 <- ();
    return _0
  }
  
end
module Borrows_FrozenDead_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Core_Num_Impl2_Max_Stub as Max0
  val frozen_dead [#"../borrows.rs" 68 0 68 66] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) (y : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 66 11 66 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 67 11 67 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 68 27 68 28] Invariant0.invariant' x}
    requires {[#"../borrows.rs" 68 47 68 48] Invariant0.invariant' y}
    
end
module Borrows_FrozenDead
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Borrows_Impl0_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg frozen_dead [#"../borrows.rs" 68 0 68 66] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) (y : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 66 11 66 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 67 11 67 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 68 27 68 28] Invariant0.invariant' x}
    requires {[#"../borrows.rs" 68 47 68 48] Invariant0.invariant' y}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var y_2 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var a_5 : borrowed int32;
  var _6 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _7 : ();
  var _8 : borrowed int32;
  var _9 : borrowed (Borrows_NonZero_Type.t_nonzero);
  {
    x_1 <- x;
    y_2 <- y;
    goto BB0
  }
  BB0 {
    a_5 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * x_1));
    x_1 <- { x_1 with current = (let Borrows_NonZero_Type.C_NonZero a =  * x_1 in Borrows_NonZero_Type.C_NonZero ( ^ a_5)) };
    _6 <- borrow_mut ( * y_2);
    y_2 <- { y_2 with current = ( ^ _6) };
    assume { Invariant1.invariant' ( ^ _6) };
    _9 <- _6;
    _6 <- any borrowed (Borrows_NonZero_Type.t_nonzero);
    assert { Invariant0.invariant' x_1 };
    assume { Resolve0.resolve x_1 };
    x_1 <- _9;
    assert { Invariant0.invariant' x_1 };
    assume { Resolve0.resolve x_1 };
    _8 <- borrow_mut ( * a_5);
    a_5 <- { a_5 with current = ( ^ _8) };
    _7 <- ([#"../borrows.rs" 73 4 73 10] Inc0.inc _8);
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve a_5 };
    _0 <- ();
    assert { Invariant0.invariant' y_2 };
    assume { Resolve0.resolve y_2 };
    return _0
  }
  
end
module Borrows_SumTo10_Type
  use prelude.Int
  use prelude.Int32
  type t_sumto10  =
    | C_SumTo10 int32 int32
    
  let function sumto10_a (self : t_sumto10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_SumTo10 a _ -> a
      end
  let function sumto10_b (self : t_sumto10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_SumTo10 _ a -> a
      end
end
module Borrows_Impl2_Invariant_Stub
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant' [#"../borrows.rs" 83 4 83 30] (self : Borrows_SumTo10_Type.t_sumto10)
end
module Borrows_Impl2_Invariant_Interface
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant' [#"../borrows.rs" 83 4 83 30] (self : Borrows_SumTo10_Type.t_sumto10)
end
module Borrows_Impl2_Invariant
  use prelude.Int32
  use prelude.Int
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant' [#"../borrows.rs" 83 4 83 30] (self : Borrows_SumTo10_Type.t_sumto10) =
    [#"../borrows.rs" 84 20 84 43] Int32.to_int (Borrows_SumTo10_Type.sumto10_a self) + Int32.to_int (Borrows_SumTo10_Type.sumto10_b self) = 10
  val invariant' [#"../borrows.rs" 83 4 83 30] (self : Borrows_SumTo10_Type.t_sumto10) : bool
    ensures { result = invariant' self }
    
end
module Core_Num_Impl2_Min_Stub
  use prelude.Int
  use prelude.Int32
  val constant mIN'  : int32
end
module Core_Num_Impl2_Min
  use prelude.Int
  use prelude.Int32
  let constant mIN'  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (-2147483648 : int32)
end
module Borrows_Dec_Interface
  use prelude.Int32
  use prelude.Int
  use prelude.Borrow
  use prelude.Int
  clone Core_Num_Impl2_Min_Stub as Min0
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int
  val dec [#"../borrows.rs" 104 0 104 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 102 11 102 25] ShallowModel0.shallow_model x > Int32.to_int Min0.mIN'}
    ensures { [#"../borrows.rs" 103 10 103 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x - 1 }
    
end
module Borrows_Dec
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Min as Min0
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg dec [#"../borrows.rs" 104 0 104 23] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 102 11 102 25] ShallowModel0.shallow_model x > Int32.to_int Min0.mIN'}
    ensures { [#"../borrows.rs" 103 10 103 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x - 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x_1 : borrowed int32;
  {
    x_1 <- x;
    goto BB0
  }
  BB0 {
    x_1 <- { x_1 with current = ([#"../borrows.rs" 105 4 105 11]  * x_1 - ([#"../borrows.rs" 105 10 105 11] (1 : int32))) };
    assume { Resolve0.resolve x_1 };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Impl3_Foo_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Borrows_SumTo10_Type.t_sumto10
  clone Core_Num_Impl2_Max_Stub as Max0
  val foo [#"../borrows.rs" 90 4 90 25] (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : ()
    requires {[#"../borrows.rs" 89 15 89 34] Int32.to_int (Borrows_SumTo10_Type.sumto10_a ( * self)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 90 20 90 24] Invariant0.invariant' self}
    
end
module Borrows_Impl3_Foo
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  clone Core_Num_Impl2_Min as Min0
  use prelude.Int
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  clone Borrows_Impl2_Invariant as Invariant1
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_SumTo10_Type.t_sumto10
  clone Borrows_Dec_Interface as Dec0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Min0.mIN' = Min0.mIN'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Core_Num_Impl2_Max as Max0
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Borrows_SumTo10_Type.t_sumto10,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg foo [#"../borrows.rs" 90 4 90 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : ()
    requires {[#"../borrows.rs" 89 15 89 34] Int32.to_int (Borrows_SumTo10_Type.sumto10_a ( * self)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 90 20 90 24] Invariant0.invariant' self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Borrows_SumTo10_Type.t_sumto10);
  var _3 : ();
  var _4 : borrowed int32;
  var _5 : borrowed int32;
  var _6 : ();
  var _7 : borrowed int32;
  var _8 : borrowed int32;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Borrows_SumTo10_Type.sumto10_a ( * self_1));
    self_1 <- { self_1 with current = (let Borrows_SumTo10_Type.C_SumTo10 a b =  * self_1 in Borrows_SumTo10_Type.C_SumTo10 ( ^ _5) b) };
    _4 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _4) };
    _3 <- ([#"../borrows.rs" 91 8 91 24] Inc0.inc _4);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _5 };
    _8 <- borrow_mut (Borrows_SumTo10_Type.sumto10_b ( * self_1));
    self_1 <- { self_1 with current = (let Borrows_SumTo10_Type.C_SumTo10 a b =  * self_1 in Borrows_SumTo10_Type.C_SumTo10 a ( ^ _8)) };
    _7 <- borrow_mut ( * _8);
    _8 <- { _8 with current = ( ^ _7) };
    _6 <- ([#"../borrows.rs" 92 8 92 24] Dec0.dec _7);
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve _8 };
    assert { Invariant0.invariant' self_1 };
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Impl0
  
end
module Borrows_Impl2
  
end

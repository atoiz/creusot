
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
  function any_l (_ : 'b) : 'a
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
  function any_l (_ : 'b) : 'a
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
  function any_l (_ : 'b) : 'a
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't))= any
    [ good (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_RawVec_Cap_Type
  use prelude.UIntSize
  use prelude.Int
  type t_cap  =
    | C_Cap usize
    
  function any_l (_ : 'b) : 'a
  let rec t_cap (input:t_cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0})
    | bad (field_0:usize)-> {C_Cap field_0 <> input} {false} any ]
    
end
module Alloc_RawVec_RawVec_Type
  use Alloc_RawVec_Cap_Type as Alloc_RawVec_Cap_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) (Alloc_RawVec_Cap_Type.t_cap) 'a
    
  function any_l (_ : 'b) : 'a
  let rec t_rawvec < 't > < 'a > (input:t_rawvec 't 'a) (ret  (ptr:Core_Ptr_Unique_Unique_Type.t_unique 't) (cap:Alloc_RawVec_Cap_Type.t_cap) (alloc:'a))= any
    [ good (ptr:Core_Ptr_Unique_Unique_Type.t_unique 't) (cap:Alloc_RawVec_Cap_Type.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc
      = input}
      (! ret {ptr} {cap} {alloc})
    | bad (ptr:Core_Ptr_Unique_Unique_Type.t_unique 't) (cap:Alloc_RawVec_Cap_Type.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc
      <> input}
      {false}
      any ]
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
  function any_l (_ : 'b) : 'a
  let rec t_vec < 't > < 'a > (input:t_vec 't 'a) (ret  (buf:Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) (len:usize))= any
    [ good (buf:Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len})
    | bad (buf:Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len <> input} {false} any ]
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
  function any_l (_ : 'b) : 'a
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module ListReversalLasso_Memory_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_memory  =
    | C_Memory (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
    
  function any_l (_ : 'b) : 'a
  let rec t_memory (input:t_memory) (ret  (field_0:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)))= any
    [ good (field_0:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))-> {C_Memory field_0 = input}
      (! ret {field_0})
    | bad (field_0:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))-> {C_Memory field_0 <> input}
      {false}
      any ]
    
  function memory_0 (self : t_memory) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) =
    match self with
      | C_Memory a -> a
      end
end
module ListReversalLasso_Impl1_Index
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 28 15 28 34
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 29 14 29 44
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span5 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span6 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span7 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span8 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span9 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span10 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span11 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  let%span span12 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  let%span span13 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  let%span span15 = "" 0 0 0 0
  let%span span16 = "" 0 0 0 0
  let%span span17 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  let%span span18 = "" 0 0 0 0
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'4 (self : Seq.seq usize) =
    [%#span2] true
  let rec invariant'4 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Seq.seq usize)
  let rec inv'4 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Seq.seq usize . inv'4 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span3] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'3 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  function shallow_model'1 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span4] inv'3 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'1 self} (! return' {result}) ] 
  axiom shallow_model'1_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span4] inv'3 self)
   -> ([%#span6] inv'4 (shallow_model'1 self))
  && ([%#span5] Seq.length (shallow_model'1 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span7] inv'4 (shallow_model'1 self)
  let rec invariant'3 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  axiom inv'3 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'3 x = true
  predicate invariant'2 (self : usize) =
    [%#span2] true
  let rec invariant'2 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : usize)
  let rec inv'2 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : usize . inv'2 x = true
  predicate invariant'1 (self : usize) =
    [%#span2] true
  let rec invariant'1 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : usize)
  let rec inv'1 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : usize . inv'1 x = true
  predicate invariant'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span2] true
  let rec invariant'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'0 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'0 x = true
  use seq.Seq
  function index_logic'1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span8] Seq.get (shallow_model'1 self) (UIntSize.to_int ix)
  let rec index_logic'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self ix} (! return' {result}) ]
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span9] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span10] Seq.length (shallow_model'1 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'1 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  use prelude.Intrinsic
  use prelude.Borrow
  use prelude.Slice
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) =
    [%#span11] Seq.get seq (UIntSize.to_int self) = out
  let rec has_value'0 (self:usize) (seq:Seq.seq usize) (out:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_value'0 self seq out} (! return' {result}) ]
    
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) =
    [%#span12] UIntSize.to_int self < Seq.length seq
  let rec in_bounds'0 (self:usize) (seq:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = in_bounds'0 self seq} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize =
    [%#span13] shallow_model'1 self
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= any
    [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  let rec index'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (index:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span16] inv'1 index}
    {[@expl:precondition] [%#span15] inv'0 self}
    {[@expl:precondition] [%#span14] in_bounds'0 index (shallow_model'0 self)}
    any
    [ return' (result:usize)-> {[%#span18] inv'2 result}
      {[%#span17] has_value'0 index (shallow_model'0 self) result}
      (! return' {result}) ]
    
  let rec index (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= {[%#slist_reversal_lasso0] nonnull_ptr'0 self i}
    (! bb0
    [ bb0 = s0
      [ s0 = ListReversalLasso_Memory_Type.t_memory {self}
          (fun (r0'0:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) ->
            index'0 {r0'0} {i} (fun (_ret':usize) ->  [ &_6 <- _ret' ] s1))
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_5 <- _6 ] s1 | s1 =  [ &_0 <- _5 ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l () : usize
    | & self : ListReversalLasso_Memory_Type.t_memory = self
    | & i : usize = i
    | & _5 : usize = any_l () : usize
    | & _6 : usize = any_l () : usize ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso1] result = index_logic'0 self i}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl2_IndexMut
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 36 15 36 34
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 39 14 39 47
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 40 4 40 113
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span8 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span10 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span11 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span12 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span13 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span14 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  let%span span15 = "../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96
  let%span span16 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  let%span span17 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  let%span span18 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  let%span span20 = "" 0 0 0 0
  let%span span21 = "" 0 0 0 0
  let%span span22 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  let%span span23 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  let%span span24 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  let%span span25 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  let%span span26 = "" 0 0 0 0
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'4 (self : Seq.seq usize) =
    [%#span5] true
  let rec invariant'4 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Seq.seq usize)
  let rec inv'4 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Seq.seq usize . inv'4 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span6] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'3 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span7] inv'3 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span7] inv'3 self)
   -> ([%#span9] inv'4 (shallow_model'0 self))
  && ([%#span8] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span10] inv'4 (shallow_model'0 self)
  let rec invariant'3 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  axiom inv'3 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'3 x = true
  use prelude.Borrow
  predicate invariant'2 (self : borrowed usize) =
    [%#span5] true
  let rec invariant'2 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed usize)
  let rec inv'2 (_x:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed usize . inv'2 x = true
  predicate invariant'1 (self : usize) =
    [%#span5] true
  let rec invariant'1 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : usize)
  let rec inv'1 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : usize . inv'1 x = true
  predicate invariant'0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) =
    [%#span5] true
  let rec invariant'0 (self:borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)))
  let rec inv'0 (_x:borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) . inv'0 x = true
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  use seq.Seq
  function index_logic'1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span11] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self ix} (! return' {result}) ]
    
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span12] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span13] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [%#span14]  ^ self =  * self
  let rec resolve'1 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed usize) =
    [%#span14]  ^ self =  * self
  let rec resolve'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Slice
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq usize) (fin : Seq.seq usize) =
    [%#span15] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  let rec resolve_elswhere'0 (self:usize) (old':Seq.seq usize) (fin:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve_elswhere'0 self old' fin} (! return' {result}) ]
    
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) =
    [%#span16] Seq.get seq (UIntSize.to_int self) = out
  let rec has_value'0 (self:usize) (seq:Seq.seq usize) (out:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_value'0 self seq out} (! return' {result}) ]
    
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) =
    [%#span17] UIntSize.to_int self < Seq.length seq
  let rec in_bounds'0 (self:usize) (seq:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = in_bounds'0 self seq} (! return' {result}) ]
    
  function shallow_model'1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : Seq.seq usize
    
   =
    [%#span18] shallow_model'0 ( * self)
  let rec shallow_model'1 (self:borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:Seq.seq usize))= any
    [ return' (result:Seq.seq usize)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) (index:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span21] inv'1 index}
    {[@expl:precondition] [%#span20] inv'0 self}
    {[@expl:precondition] [%#span19] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:borrowed usize)-> {[%#span26] inv'2 result}
      {[%#span25] Seq.length (shallow_model'0 ( ^ self)) = Seq.length (shallow_model'1 self)}
      {[%#span24] resolve_elswhere'0 index (shallow_model'1 self) (shallow_model'0 ( ^ self))}
      {[%#span23] has_value'0 index (shallow_model'0 ( ^ self)) ( ^ result)}
      {[%#span22] has_value'0 index (shallow_model'1 self) ( * result)}
      (! return' {result}) ]
    
  let rec index_mut (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[%#slist_reversal_lasso0] nonnull_ptr'0 ( * self) i}
    (! bb0
    [ bb0 = s0
      [ s0 = ListReversalLasso_Memory_Type.t_memory { * self}
          (fun (r0'0:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) ->
            Borrow.borrow_final
              <Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)>
              {r0'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) ->
                 [ &_11 <- _ret' ] 
                ListReversalLasso_Memory_Type.t_memory { * self}
                  (fun (l_0'0:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) ->
                    
                    [ &self <- { self with current = (ListReversalLasso_Memory_Type.C_Memory ( ^ _11) : ListReversalLasso_Memory_Type.t_memory) ; } ]
                    
                    s1)))
      | s1 = index_mut'0 {_11} {i} (fun (_ret':borrowed usize) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <usize> { * _10} {Borrow.get_id _10}
          (fun (_ret':borrowed usize) ->  [ &_9 <- _ret' ]  [ &_10 <- { _10 with current = ( ^ _9) ; } ] s1)
      | s1 = Borrow.borrow_final <usize> { * _9} {Borrow.get_id _9}
          (fun (_ret':borrowed usize) ->  [ &_3 <- _ret' ]  [ &_9 <- { _9 with current = ( ^ _3) ; } ] s2)
      | s2 = Borrow.borrow_final <usize> { * _3} {Borrow.get_id _3}
          (fun (_ret':borrowed usize) ->  [ &_0 <- _ret' ]  [ &_3 <- { _3 with current = ( ^ _0) ; } ] s3)
      | s3 = -{resolve'0 _10}- s4
      | s4 = -{resolve'0 _9}- s5
      | s5 = -{resolve'0 _3}- s6
      | s6 = -{resolve'1 self}- s7
      | s7 = return' {_0} ]
       ]
    )
    [ & _0 : borrowed usize = any_l () : borrowed usize
    | & self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self
    | & i : usize = i
    | & _3 : borrowed usize = any_l () : borrowed usize
    | & _9 : borrowed usize = any_l () : borrowed usize
    | & _10 : borrowed usize = any_l () : borrowed usize
    | & _11 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) = any_l () : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) ]
    
    [ return' (result:borrowed usize)-> {[@expl:postcondition] [%#slist_reversal_lasso4] forall j : usize . nonnull_ptr'0 ( * self) j
      /\ i <> j  -> index_logic'0 ( ^ self) j = index_logic'0 ( * self) j}
      {[@expl:postcondition] [%#slist_reversal_lasso3] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[@expl:postcondition] [%#slist_reversal_lasso2]  ^ result = index_logic'0 ( ^ self) i}
      {[@expl:postcondition] [%#slist_reversal_lasso1]  * result = index_logic'0 ( * self) i}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl4_ListReversalSafe
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 66 20 66 24
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 68 20 68 52
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 69 20 69 52
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 70 20 70 45
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 71 19 71 23
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 63 15 63 40
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 64 15 64 47
  let%span span7 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span8 = "" 0 0 0 0
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span10 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span13 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  let%span span14 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span15 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span16 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span17 = "../list_reversal_lasso.rs" 36 15 36 34
  let%span span18 = "../list_reversal_lasso.rs" 37 14 37 47
  let%span span19 = "../list_reversal_lasso.rs" 38 14 38 47
  let%span span20 = "../list_reversal_lasso.rs" 39 14 39 47
  let%span span21 = "../list_reversal_lasso.rs" 40 4 40 113
  let%span span22 = "../list_reversal_lasso.rs" 28 15 28 34
  let%span span23 = "../list_reversal_lasso.rs" 29 14 29 44
  let%span span24 = "../list_reversal_lasso.rs" 13 0 13 15
  let%span span25 = "../list_reversal_lasso.rs" 56 8 58 9
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'1 (self : Seq.seq usize) =
    [%#span7] true
  let rec invariant'1 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Seq.seq usize)
  let rec inv'1 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Seq.seq usize . inv'1 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span8] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'0 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span9] inv'0 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span9] inv'0 self)
   -> ([%#span11] inv'1 (shallow_model'0 self))
  && ([%#span10] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span12] inv'1 (shallow_model'0 self)
  let rec invariant'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  axiom inv'0 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Borrow
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate resolve'1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [%#span13]  ^ self =  * self
  let rec resolve'1 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed usize) =
    [%#span13]  ^ self =  * self
  let rec resolve'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use seq.Seq
  function index_logic'1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span14] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self ix} (! return' {result}) ]
    
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span15] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span16] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span17] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span21] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'0 ( ^ self) j = index_logic'0 ( * self) j}
      {[%#span20] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span19]  ^ result = index_logic'0 ( ^ self) i}
      {[%#span18]  * result = index_logic'0 ( * self) i}
      (! return' {result}) ]
    
  let rec index'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span22] nonnull_ptr'0 self i}
    any [ return' (result:usize)-> {[%#span23] result = index_logic'0 self i} (! return' {result}) ] 
  constant null'0 : usize = [%#span24] (18446744073709551615 : usize)
  predicate mem_is_well_formed'0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
    
   =
    [%#span25] forall i : usize . nonnull_ptr'0 self i
     -> index_logic'0 self i = null'0 \/ nonnull_ptr'0 self (index_logic'0 self i)
  let rec mem_is_well_formed'0 (self:ListReversalLasso_Memory_Type.t_memory) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = mem_is_well_formed'0 self} (! return' {result}) ]
    
  let rec list_reversal_safe (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (l:usize) (return'  (ret:usize))= {[%#slist_reversal_lasso6] l
    = null'0
    \/ nonnull_ptr'0 ( * self) l}
    {[%#slist_reversal_lasso5] mem_is_well_formed'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1 | s1 = bb1 ] 
    | bb1 = bb1
      [ bb1 = {[@expl:loop invariant] [%#slist_reversal_lasso3] mem_is_well_formed'0 ( * self)}
        {[@expl:loop invariant] [%#slist_reversal_lasso2] l = null'0 \/ nonnull_ptr'0 ( * self) l}
        {[@expl:loop invariant] [%#slist_reversal_lasso1] r = null'0 \/ nonnull_ptr'0 ( * self) r}
        (! s0) [ s0 = bb2 ] 
        [ bb2 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso4] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
          | s1 = any [ br0 -> {_12 = false} (! bb6) | br1 -> {_12} (! bb3) ]  ]
          
        | bb3 = s0
          [ s0 =  [ &tmp <- l ] s1
          | s1 = index'0 { * self} {l} (fun (_ret':usize) ->  [ &_16 <- _ret' ] s2)
          | s2 = bb4 ]
          
        | bb4 = s0
          [ s0 =  [ &l <- _16 ] s1
          | s1 = Borrow.borrow_mut <ListReversalLasso_Memory_Type.t_memory> { * self}
              (fun (_ret':borrowed (ListReversalLasso_Memory_Type.t_memory)) ->
                 [ &_21 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _21) ; } ] 
                s2)
          | s2 = index_mut'0 {_21} {tmp} (fun (_ret':borrowed usize) ->  [ &_20 <- _ret' ] s3)
          | s3 = bb5 ]
          
        | bb5 = s0
          [ s0 =  [ &_20 <- { _20 with current = r ; } ] s1
          | s1 = -{resolve'0 _20}- s2
          | s2 =  [ &r <- tmp ] s3
          | s3 = bb1 ]
           ]
         ]
      
    | bb6 = s0 [ s0 = -{resolve'1 self}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l () : usize
    | & self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self
    | & l : usize = l
    | & r : usize = any_l () : usize
    | & _12 : bool = any_l () : bool
    | & tmp : usize = any_l () : usize
    | & _16 : usize = any_l () : usize
    | & _20 : borrowed usize = any_l () : borrowed usize
    | & _21 : borrowed (ListReversalLasso_Memory_Type.t_memory) = any_l () : borrowed (ListReversalLasso_Memory_Type.t_memory) ]
     [ return' (result:usize)-> (! return' {result}) ] 
end
module ListReversalLasso_Impl4_ListReversalList
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 100 23 100 41
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 101 20 101 24
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 102 20 102 35
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 104 20 104 44
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 105 20 105 59
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 106 20 106 76
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 108 20 108 39
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 109 19 109 23
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 111 16 111 36
  let%span slist_reversal_lasso9 = "../list_reversal_lasso.rs" 97 15 97 31
  let%span slist_reversal_lasso10 = "../list_reversal_lasso.rs" 98 14 98 47
  let%span span11 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span12 = "" 0 0 0 0
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span15 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span16 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span17 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span18 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span19 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span20 = "../list_reversal_lasso.rs" 83 12 85 98
  let%span span21 = "../list_reversal_lasso.rs" 13 0 13 15
  let%span span22 = "../list_reversal_lasso.rs" 93 12 93 53
  let%span span23 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  let%span span24 = "" 0 0 0 0
  let%span span25 = "" 0 0 0 0
  let%span span26 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span span27 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span span28 = "" 0 0 0 0
  let%span span29 = "../list_reversal_lasso.rs" 36 15 36 34
  let%span span30 = "../list_reversal_lasso.rs" 37 14 37 47
  let%span span31 = "../list_reversal_lasso.rs" 38 14 38 47
  let%span span32 = "../list_reversal_lasso.rs" 39 14 39 47
  let%span span33 = "../list_reversal_lasso.rs" 40 4 40 113
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'3 (self : Seq.seq usize) =
    [%#span11] true
  let rec invariant'3 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Seq.seq usize)
  let rec inv'3 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Seq.seq usize . inv'3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span12] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'2 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span13] inv'2 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span13] inv'2 self)
   -> ([%#span15] inv'3 (shallow_model'0 self))
  && ([%#span14] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span16] inv'3 (shallow_model'0 self)
  let rec invariant'2 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'2 x = true
  predicate invariant'1 (self : usize) =
    [%#span11] true
  let rec invariant'1 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : usize)
  let rec inv'1 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : usize . inv'1 x = true
  use prelude.Borrow
  predicate invariant'0 (self : borrowed usize) =
    [%#span11] true
  let rec invariant'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed usize)
  let rec inv'0 (_x:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed usize . inv'0 x = true
  use seq.Seq
  function index_logic'1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span17] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self ix} (! return' {result}) ]
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span18] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span19] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span20] first = (if h = l then last else Seq.get s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  let rec list_seg'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (last:usize) (l:int) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list_seg'0 self first s last l h} (! return' {result}) ]
    
  constant null'0 : usize = [%#span21] (18446744073709551615 : usize)
  predicate list'0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [%#span22] list_seg'0 self first s null'0 0 (Seq.length s)
  let rec list'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list'0 self first s} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [%#span23]  ^ self =  * self
  let rec resolve'1 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Int
  predicate resolve'0 (self : borrowed usize) =
    [%#span23]  ^ self =  * self
  let rec resolve'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec replace'0 (dest:borrowed usize) (src:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span25] inv'1 src}
    {[@expl:precondition] [%#span24] inv'0 dest}
    any
    [ return' (result:usize)-> {[%#span28] inv'1 result}
      {[%#span27] result =  * dest}
      {[%#span26]  ^ dest = src}
      (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span29] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span33] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'0 ( ^ self) j = index_logic'0 ( * self) j}
      {[%#span32] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span31]  ^ result = index_logic'0 ( ^ self) i}
      {[%#span30]  * result = index_logic'0 ( * self) i}
      (! return' {result}) ]
    
  use prelude.Snapshot
  use seq.Reverse
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  let rec list_reversal_list (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (l:usize) (s:Snapshot.snap_ty (Seq.seq usize)) (return'  (ret:usize))= {[%#slist_reversal_lasso9] list'0 ( * self) l (Snapshot.inner s)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#slist_reversal_lasso0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso1] (18446744073709551615 : usize) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso2] Snapshot.new 0 ] s2
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant] [%#slist_reversal_lasso6]  ^ Snapshot.inner old_self =  ^ self}
        {[@expl:loop invariant] [%#slist_reversal_lasso5] list_seg'0 ( * self) r (Reverse.reverse (Snapshot.inner s)) null'0 (Seq.length (Snapshot.inner s)
        - Snapshot.inner n) (Seq.length (Snapshot.inner s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso4] list_seg'0 ( * self) l (Snapshot.inner s) null'0 (Snapshot.inner n) (Seq.length (Snapshot.inner s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] 0 <= Snapshot.inner n
        /\ Snapshot.inner n <= Seq.length (Snapshot.inner s)}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso7] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
          | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]  ]
          
        | bb5 = s0
          [ s0 = Borrow.borrow_mut <ListReversalLasso_Memory_Type.t_memory> { * self}
              (fun (_ret':borrowed (ListReversalLasso_Memory_Type.t_memory)) ->
                 [ &_24 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _24) ; } ] 
                s1)
          | s1 = index_mut'0 {_24} {l} (fun (_ret':borrowed usize) ->  [ &_23 <- _ret' ] s2)
          | s2 = bb6 ]
          
        | bb6 = s0
          [ s0 = Borrow.borrow_final <usize> { * _23} {Borrow.get_id _23}
              (fun (_ret':borrowed usize) ->  [ &_22 <- _ret' ]  [ &_23 <- { _23 with current = ( ^ _22) ; } ] s1)
          | s1 = Borrow.borrow_final <usize> { * _22} {Borrow.get_id _22}
              (fun (_ret':borrowed usize) ->  [ &_21 <- _ret' ]  [ &_22 <- { _22 with current = ( ^ _21) ; } ] s2)
          | s2 = Borrow.borrow_mut <usize> {r} (fun (_ret':borrowed usize) ->  [ &_28 <- _ret' ]  [ &r <-  ^ _28 ] s3)
          | s3 = Borrow.borrow_final <usize> { * _28} {Borrow.get_id _28}
              (fun (_ret':borrowed usize) ->  [ &_27 <- _ret' ]  [ &_28 <- { _28 with current = ( ^ _27) ; } ] s4)
          | s4 = replace'0 {_27} {l} (fun (_ret':usize) ->  [ &_26 <- _ret' ] s5)
          | s5 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _28}- s1
          | s1 = replace'0 {_21} {_26} (fun (_ret':usize) ->  [ &_20 <- _ret' ] s2)
          | s2 = bb8 ]
          
        | bb8 = s0
          [ s0 = -{resolve'0 _23}- s1
          | s1 = -{resolve'0 _22}- s2
          | s2 =  [ &l <- _20 ] (any [ any_ (_any:usize)-> (!  [ &_20 <- _any ] s3) ] )
          | s3 =  [ &_30 <- [%#slist_reversal_lasso8] Snapshot.new (Snapshot.inner n + 1) ] s4
          | s4 = bb9 ]
          
        | bb9 = s0
          [ s0 =  [ &n <- _30 ] (any [ any_ (_any:Snapshot.snap_ty int)-> (!  [ &_30 <- _any ] s1) ] ) | s1 = bb3 ]
           ]
         ]
      
    | bb10 = s0 [ s0 = -{resolve'1 self}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l () : usize
    | & self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self
    | & l : usize = l
    | & s : Snapshot.snap_ty (Seq.seq usize) = s
    | & old_self : Snapshot.snap_ty (borrowed (ListReversalLasso_Memory_Type.t_memory)) = any_l () : Snapshot.snap_ty (borrowed (ListReversalLasso_Memory_Type.t_memory))
    | & r : usize = any_l () : usize
    | & n : Snapshot.snap_ty int = any_l () : Snapshot.snap_ty int
    | & _18 : bool = any_l () : bool
    | & _20 : usize = any_l () : usize
    | & _21 : borrowed usize = any_l () : borrowed usize
    | & _22 : borrowed usize = any_l () : borrowed usize
    | & _23 : borrowed usize = any_l () : borrowed usize
    | & _24 : borrowed (ListReversalLasso_Memory_Type.t_memory) = any_l () : borrowed (ListReversalLasso_Memory_Type.t_memory)
    | & _26 : usize = any_l () : usize
    | & _27 : borrowed usize = any_l () : borrowed usize
    | & _28 : borrowed usize = any_l () : borrowed usize
    | & _30 : Snapshot.snap_ty int = any_l () : Snapshot.snap_ty int ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso10] list'0 ( ^ self) result (Reverse.reverse (Snapshot.inner s))}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl4_ListReversalLoop
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 128 20 128 24
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 129 20 129 35
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 130 23 130 41
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 132 20 132 39
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 133 20 133 48
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 132 8 132 41
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 141 19 141 23
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 142 12 142 77
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 144 16 144 36
  let%span slist_reversal_lasso9 = "../list_reversal_lasso.rs" 147 8 149 54
  let%span slist_reversal_lasso10 = "../list_reversal_lasso.rs" 124 15 124 26
  let%span slist_reversal_lasso11 = "../list_reversal_lasso.rs" 125 15 125 32
  let%span slist_reversal_lasso12 = "../list_reversal_lasso.rs" 126 14 126 101
  let%span span13 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span14 = "" 0 0 0 0
  let%span span15 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span16 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span17 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span18 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span19 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span20 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span21 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span22 = "../list_reversal_lasso.rs" 83 12 85 98
  let%span span23 = "../list_reversal_lasso.rs" 120 12 120 53
  let%span span24 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  let%span span25 = "" 0 0 0 0
  let%span span26 = "" 0 0 0 0
  let%span span27 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span span28 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span span29 = "" 0 0 0 0
  let%span span30 = "../list_reversal_lasso.rs" 36 15 36 34
  let%span span31 = "../list_reversal_lasso.rs" 37 14 37 47
  let%span span32 = "../list_reversal_lasso.rs" 38 14 38 47
  let%span span33 = "../list_reversal_lasso.rs" 39 14 39 47
  let%span span34 = "../list_reversal_lasso.rs" 40 4 40 113
  let%span span35 = "../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33
  let%span span36 = "../list_reversal_lasso.rs" 13 0 13 15
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'3 (self : Seq.seq usize) =
    [%#span13] true
  let rec invariant'3 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Seq.seq usize)
  let rec inv'3 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Seq.seq usize . inv'3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span14] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'2 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span15] inv'2 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span15] inv'2 self)
   -> ([%#span17] inv'3 (shallow_model'0 self))
  && ([%#span16] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span18] inv'3 (shallow_model'0 self)
  let rec invariant'2 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'2 x = true
  predicate invariant'1 (self : usize) =
    [%#span13] true
  let rec invariant'1 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : usize)
  let rec inv'1 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : usize . inv'1 x = true
  use prelude.Borrow
  predicate invariant'0 (self : borrowed usize) =
    [%#span13] true
  let rec invariant'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed usize)
  let rec inv'0 (_x:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed usize . inv'0 x = true
  use seq.Seq
  function index_logic'2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span19] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'2 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'2 self ix} (! return' {result}) ]
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic'1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span20] index_logic'2 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'1 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span21] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span22] first = (if h = l then last else Seq.get s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (Seq.get s i)
    /\ index_logic'1 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  let rec list_seg'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (last:usize) (l:int) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list_seg'0 self first s last l h} (! return' {result}) ]
    
  predicate loop'0 [#"../list_reversal_lasso.rs" 118 4 118 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [%#span23] list_seg'0 self first s (Seq.get s 0) 0 (Seq.length s)
  let rec loop'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = loop'0 self first s} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  use seq.Seq
  use seq_ext.SeqExt
  use seq.Seq
  predicate resolve'1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [%#span24]  ^ self =  * self
  let rec resolve'1 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Int
  predicate resolve'0 (self : borrowed usize) =
    [%#span24]  ^ self =  * self
  let rec resolve'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec replace'0 (dest:borrowed usize) (src:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span26] inv'1 src}
    {[@expl:precondition] [%#span25] inv'0 dest}
    any
    [ return' (result:usize)-> {[%#span29] inv'1 result}
      {[%#span28] result =  * dest}
      {[%#span27]  ^ dest = src}
      (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span30] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span34] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'1 ( ^ self) j = index_logic'1 ( * self) j}
      {[%#span33] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span32]  ^ result = index_logic'1 ( ^ self) i}
      {[%#span31]  * result = index_logic'1 ( * self) i}
      (! return' {result}) ]
    
  use seq.Reverse
  use prelude.Snapshot
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq usize)) (ix : int) : usize =
    [%#span35] Seq.get (Snapshot.inner self) ix
  let rec index_logic'0 (self:Snapshot.snap_ty (Seq.seq usize)) (ix:int) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  constant null'0 : usize = [%#span36] (18446744073709551615 : usize)
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  let rec list_reversal_loop (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (l:usize) (s:Snapshot.snap_ty (Seq.seq usize)) (return'  (ret:usize))= {[%#slist_reversal_lasso11] loop'0 ( * self) l (Snapshot.inner s)}
    {[%#slist_reversal_lasso10] Seq.length (Snapshot.inner s) > 0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso1] Snapshot.new 0 ] s2
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &old_self <- [%#slist_reversal_lasso2] Snapshot.new self ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant] [%#slist_reversal_lasso5] Snapshot.inner n <= Seq.length (Snapshot.inner s)
         -> list_seg'0 ( * self) r (Reverse.reverse (Snapshot.inner s)) null'0 (Seq.length (Snapshot.inner s)
        - Snapshot.inner n) (Seq.length (Snapshot.inner s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso5] Snapshot.inner n <= Seq.length (Snapshot.inner s)
         -> list_seg'0 ( * self) l (Snapshot.inner s) (index_logic'0 s 0) (Snapshot.inner n) (Seq.length (Snapshot.inner s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso5] Snapshot.inner n = Seq.length (Snapshot.inner s) + 1
         -> l = null'0
        /\ r = index_logic'0 s 0
        /\ nonnull_ptr'0 ( * self) r
        /\ index_logic'1 ( * self) r = index_logic'0 s (Seq.length (Snapshot.inner s) - 1)
        /\ list_seg'0 ( * self) (index_logic'0 s (Seq.length (Snapshot.inner s)
        - 1)) (Reverse.reverse (Snapshot.inner s)) (index_logic'0 s 0) 0 (Seq.length (Snapshot.inner s) - 1)}
        {[@expl:loop invariant] [%#slist_reversal_lasso4] 0 <= Snapshot.inner n
        /\ Snapshot.inner n <= Seq.length (Snapshot.inner s) + 1}
        {[@expl:loop invariant] [%#slist_reversal_lasso3]  ^ Snapshot.inner old_self =  ^ self}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso6] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
          | s1 = any [ br0 -> {_20 = false} (! bb10) | br1 -> {_20} (! bb5) ]  ]
          
        | bb5 = s0
          [ s0 = {[@expl:assertion] [%#slist_reversal_lasso7] Snapshot.inner n = Seq.length (Snapshot.inner s)
             -> l = Seq.get (Reverse.reverse (Snapshot.inner s)) (Seq.length (Snapshot.inner s) - 1)}
            s1
          | s1 = Borrow.borrow_mut <ListReversalLasso_Memory_Type.t_memory> { * self}
              (fun (_ret':borrowed (ListReversalLasso_Memory_Type.t_memory)) ->
                 [ &_28 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _28) ; } ] 
                s2)
          | s2 = index_mut'0 {_28} {l} (fun (_ret':borrowed usize) ->  [ &_27 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = s0
          [ s0 = Borrow.borrow_final <usize> { * _27} {Borrow.get_id _27}
              (fun (_ret':borrowed usize) ->  [ &_26 <- _ret' ]  [ &_27 <- { _27 with current = ( ^ _26) ; } ] s1)
          | s1 = Borrow.borrow_final <usize> { * _26} {Borrow.get_id _26}
              (fun (_ret':borrowed usize) ->  [ &_25 <- _ret' ]  [ &_26 <- { _26 with current = ( ^ _25) ; } ] s2)
          | s2 = Borrow.borrow_mut <usize> {r} (fun (_ret':borrowed usize) ->  [ &_32 <- _ret' ]  [ &r <-  ^ _32 ] s3)
          | s3 = Borrow.borrow_final <usize> { * _32} {Borrow.get_id _32}
              (fun (_ret':borrowed usize) ->  [ &_31 <- _ret' ]  [ &_32 <- { _32 with current = ( ^ _31) ; } ] s4)
          | s4 = replace'0 {_31} {l} (fun (_ret':usize) ->  [ &_30 <- _ret' ] s5)
          | s5 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _32}- s1
          | s1 = replace'0 {_25} {_30} (fun (_ret':usize) ->  [ &_24 <- _ret' ] s2)
          | s2 = bb8 ]
          
        | bb8 = s0
          [ s0 = -{resolve'0 _27}- s1
          | s1 = -{resolve'0 _26}- s2
          | s2 =  [ &l <- _24 ] (any [ any_ (_any:usize)-> (!  [ &_24 <- _any ] s3) ] )
          | s3 =  [ &_34 <- [%#slist_reversal_lasso8] Snapshot.new (Snapshot.inner n + 1) ] s4
          | s4 = bb9 ]
          
        | bb9 = s0
          [ s0 =  [ &n <- _34 ] (any [ any_ (_any:Snapshot.snap_ty int)-> (!  [ &_34 <- _any ] s1) ] ) | s1 = bb3 ]
           ]
         ]
      
    | bb10 = s0
      [ s0 = -{resolve'1 self}- s1
      | s1 = {[@expl:assertion] [%#slist_reversal_lasso9] forall i : int . 0 <= i /\ i < Seq.length (Snapshot.inner s)
         -> Seq.get (Seq.(++) (Seq.singleton (index_logic'0 s 0)) (Reverse.reverse (SeqExt.subsequence (Snapshot.inner s) 1 (Seq.length (Snapshot.inner s))))) i
        = (if i = 0 then index_logic'0 s 0 else Seq.get (Reverse.reverse (Snapshot.inner s)) (i - 1))}
        s2
      | s2 =  [ &_0 <- r ] s3
      | s3 = return' {_0} ]
       ]
    )
    [ & _0 : usize = any_l () : usize
    | & self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self
    | & l : usize = l
    | & s : Snapshot.snap_ty (Seq.seq usize) = s
    | & r : usize = any_l () : usize
    | & n : Snapshot.snap_ty int = any_l () : Snapshot.snap_ty int
    | & old_self : Snapshot.snap_ty (borrowed (ListReversalLasso_Memory_Type.t_memory)) = any_l () : Snapshot.snap_ty (borrowed (ListReversalLasso_Memory_Type.t_memory))
    | & _20 : bool = any_l () : bool
    | & _24 : usize = any_l () : usize
    | & _25 : borrowed usize = any_l () : borrowed usize
    | & _26 : borrowed usize = any_l () : borrowed usize
    | & _27 : borrowed usize = any_l () : borrowed usize
    | & _28 : borrowed (ListReversalLasso_Memory_Type.t_memory) = any_l () : borrowed (ListReversalLasso_Memory_Type.t_memory)
    | & _30 : usize = any_l () : usize
    | & _31 : borrowed usize = any_l () : borrowed usize
    | & _32 : borrowed usize = any_l () : borrowed usize
    | & _34 : Snapshot.snap_ty int = any_l () : Snapshot.snap_ty int ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso12] loop'0 ( ^ self) result (Seq.(++) (Seq.singleton (index_logic'0 s 0)) (Reverse.reverse (SeqExt.subsequence (Snapshot.inner s) 1 (Seq.length (Snapshot.inner s)))))}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl4_ListReversalLasso
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 173 20 173 24
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 174 20 174 35
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 175 23 175 41
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 177 20 177 39
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 178 20 178 58
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 177 8 177 41
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 196 19 196 23
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 198 16 198 36
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 165 15 165 38
  let%span slist_reversal_lasso9 = "../list_reversal_lasso.rs" 166 14 166 54
  let%span span10 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span11 = "" 0 0 0 0
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span15 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span16 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span17 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span18 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span19 = "../list_reversal_lasso.rs" 83 12 85 98
  let%span span20 = "../list_reversal_lasso.rs" 156 8 162 9
  let%span span21 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  let%span span22 = "" 0 0 0 0
  let%span span23 = "" 0 0 0 0
  let%span span24 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span span25 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span span26 = "" 0 0 0 0
  let%span span27 = "../list_reversal_lasso.rs" 36 15 36 34
  let%span span28 = "../list_reversal_lasso.rs" 37 14 37 47
  let%span span29 = "../list_reversal_lasso.rs" 38 14 38 47
  let%span span30 = "../list_reversal_lasso.rs" 39 14 39 47
  let%span span31 = "../list_reversal_lasso.rs" 40 4 40 113
  let%span span32 = "../list_reversal_lasso.rs" 13 0 13 15
  let%span span33 = "../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'3 (self : Seq.seq usize) =
    [%#span10] true
  let rec invariant'3 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Seq.seq usize)
  let rec inv'3 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Seq.seq usize . inv'3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span11] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'2 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span12] inv'2 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span12] inv'2 self)
   -> ([%#span14] inv'3 (shallow_model'0 self))
  && ([%#span13] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span15] inv'3 (shallow_model'0 self)
  let rec invariant'2 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'2 x = true
  predicate invariant'1 (self : usize) =
    [%#span10] true
  let rec invariant'1 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : usize)
  let rec inv'1 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : usize . inv'1 x = true
  use prelude.Borrow
  predicate invariant'0 (self : borrowed usize) =
    [%#span10] true
  let rec invariant'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed usize)
  let rec inv'0 (_x:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed usize . inv'0 x = true
  use seq.Seq
  function index_logic'2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span16] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'2 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'2 self ix} (! return' {result}) ]
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic'1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span17] index_logic'2 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'1 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span18] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span19] first = (if h = l then last else Seq.get s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (Seq.get s i)
    /\ index_logic'1 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  let rec list_seg'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (last:usize) (l:int) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list_seg'0 self first s last l h} (! return' {result}) ]
    
  predicate lasso'0 [#"../list_reversal_lasso.rs" 155 4 155 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [%#span20] let mid = if Seq.length s2 = 0 then Seq.get s1 (Seq.length s1 - 1) else Seq.get s2 0 in Seq.length s1 > 0
    /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
     -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg'0 self first s1 mid 0 (Seq.length s1)
    /\ list_seg'0 self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  let rec lasso'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s1:Seq.seq usize) (s2:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lasso'0 self first s1 s2} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [%#span21]  ^ self =  * self
  let rec resolve'1 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Int
  predicate resolve'0 (self : borrowed usize) =
    [%#span21]  ^ self =  * self
  let rec resolve'0 (self:borrowed usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec replace'0 (dest:borrowed usize) (src:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span23] inv'1 src}
    {[@expl:precondition] [%#span22] inv'0 dest}
    any
    [ return' (result:usize)-> {[%#span26] inv'1 result}
      {[%#span25] result =  * dest}
      {[%#span24]  ^ dest = src}
      (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span27] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span31] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'1 ( ^ self) j = index_logic'1 ( * self) j}
      {[%#span30] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span29]  ^ result = index_logic'1 ( ^ self) i}
      {[%#span28]  * result = index_logic'1 ( * self) i}
      (! return' {result}) ]
    
  constant null'0 : usize = [%#span32] (18446744073709551615 : usize)
  use seq.Reverse
  use prelude.Snapshot
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq usize)) (ix : int) : usize =
    [%#span33] Seq.get (Snapshot.inner self) ix
  let rec index_logic'0 (self:Snapshot.snap_ty (Seq.seq usize)) (ix:int) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  let rec list_reversal_lasso (self:borrowed (ListReversalLasso_Memory_Type.t_memory)) (l:usize) (s1:Snapshot.snap_ty (Seq.seq usize)) (s2:Snapshot.snap_ty (Seq.seq usize)) (return'  (ret:usize))= {[%#slist_reversal_lasso8] lasso'0 ( * self) l (Snapshot.inner s1) (Snapshot.inner s2)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso1] Snapshot.new 0 ] s2
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &old_self <- [%#slist_reversal_lasso2] Snapshot.new self ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant] [%#slist_reversal_lasso5] let mid = if Seq.length (Snapshot.inner s2) = 0 then
          index_logic'0 s1 (Seq.length (Snapshot.inner s1) - 1)
        else
          index_logic'0 s2 (Seq.length (Snapshot.inner s2) - 1)
         in Seq.length (Snapshot.inner s1) + Seq.length (Snapshot.inner s2) < Snapshot.inner n
         -> list_seg'0 ( * self) l (Reverse.reverse (Snapshot.inner s1)) null'0 (Snapshot.inner n
        - Seq.length (Snapshot.inner s1)
        - Seq.length (Snapshot.inner s2)) (Seq.length (Snapshot.inner s1))
        /\ list_seg'0 ( * self) r (Snapshot.inner s1) mid (2 * Seq.length (Snapshot.inner s1)
        + Seq.length (Snapshot.inner s2)
        - Snapshot.inner n) (Seq.length (Snapshot.inner s1))
        /\ list_seg'0 ( * self) mid (Reverse.reverse (Snapshot.inner s2)) (index_logic'0 s1 (Seq.length (Snapshot.inner s1)
        - 1)) 0 (Seq.length (Snapshot.inner s2))}
        {[@expl:loop invariant] [%#slist_reversal_lasso5] Seq.length (Snapshot.inner s1) < Snapshot.inner n
        /\ Snapshot.inner n <= Seq.length (Snapshot.inner s1) + Seq.length (Snapshot.inner s2)
         -> list_seg'0 ( * self) l (Snapshot.inner s2) (index_logic'0 s1 (Seq.length (Snapshot.inner s1)
        - 1)) (Snapshot.inner n - Seq.length (Snapshot.inner s1)) (Seq.length (Snapshot.inner s2))
        /\ list_seg'0 ( * self) r (Reverse.reverse (Snapshot.inner s2)) (index_logic'0 s1 (Seq.length (Snapshot.inner s1)
        - 1)) (Seq.length (Snapshot.inner s1) + Seq.length (Snapshot.inner s2)
        - Snapshot.inner n) (Seq.length (Snapshot.inner s2))
        /\ list_seg'0 ( * self) (index_logic'0 s1 (Seq.length (Snapshot.inner s1)
        - 1)) (Reverse.reverse (Snapshot.inner s1)) null'0 0 (Seq.length (Snapshot.inner s1))}
        {[@expl:loop invariant] [%#slist_reversal_lasso5] let mid = if Seq.length (Snapshot.inner s2) = 0 then
          index_logic'0 s1 (Seq.length (Snapshot.inner s1) - 1)
        else
          index_logic'0 s2 0
         in Snapshot.inner n <= Seq.length (Snapshot.inner s1)
         -> list_seg'0 ( * self) l (Snapshot.inner s1) mid (Snapshot.inner n) (Seq.length (Snapshot.inner s1))
        /\ list_seg'0 ( * self) mid (Snapshot.inner s2) (index_logic'0 s1 (Seq.length (Snapshot.inner s1)
        - 1)) 0 (Seq.length (Snapshot.inner s2))
        /\ list_seg'0 ( * self) r (Reverse.reverse (Snapshot.inner s1)) null'0 (Seq.length (Snapshot.inner s1)
        - Snapshot.inner n) (Seq.length (Snapshot.inner s1))}
        {[@expl:loop invariant] [%#slist_reversal_lasso4] 0 <= Snapshot.inner n
        /\ Snapshot.inner n <= 2 * Seq.length (Snapshot.inner s1) + Seq.length (Snapshot.inner s2)}
        {[@expl:loop invariant] [%#slist_reversal_lasso3]  ^ Snapshot.inner old_self =  ^ self}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso6] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
          | s1 = any [ br0 -> {_20 = false} (! bb10) | br1 -> {_20} (! bb5) ]  ]
          
        | bb5 = s0
          [ s0 = Borrow.borrow_mut <ListReversalLasso_Memory_Type.t_memory> { * self}
              (fun (_ret':borrowed (ListReversalLasso_Memory_Type.t_memory)) ->
                 [ &_26 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _26) ; } ] 
                s1)
          | s1 = index_mut'0 {_26} {l} (fun (_ret':borrowed usize) ->  [ &_25 <- _ret' ] s2)
          | s2 = bb6 ]
          
        | bb6 = s0
          [ s0 = Borrow.borrow_final <usize> { * _25} {Borrow.get_id _25}
              (fun (_ret':borrowed usize) ->  [ &_24 <- _ret' ]  [ &_25 <- { _25 with current = ( ^ _24) ; } ] s1)
          | s1 = Borrow.borrow_final <usize> { * _24} {Borrow.get_id _24}
              (fun (_ret':borrowed usize) ->  [ &_23 <- _ret' ]  [ &_24 <- { _24 with current = ( ^ _23) ; } ] s2)
          | s2 = Borrow.borrow_mut <usize> {r} (fun (_ret':borrowed usize) ->  [ &_30 <- _ret' ]  [ &r <-  ^ _30 ] s3)
          | s3 = Borrow.borrow_final <usize> { * _30} {Borrow.get_id _30}
              (fun (_ret':borrowed usize) ->  [ &_29 <- _ret' ]  [ &_30 <- { _30 with current = ( ^ _29) ; } ] s4)
          | s4 = replace'0 {_29} {l} (fun (_ret':usize) ->  [ &_28 <- _ret' ] s5)
          | s5 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _30}- s1
          | s1 = replace'0 {_23} {_28} (fun (_ret':usize) ->  [ &_22 <- _ret' ] s2)
          | s2 = bb8 ]
          
        | bb8 = s0
          [ s0 = -{resolve'0 _25}- s1
          | s1 = -{resolve'0 _24}- s2
          | s2 =  [ &l <- _22 ] (any [ any_ (_any:usize)-> (!  [ &_22 <- _any ] s3) ] )
          | s3 =  [ &_32 <- [%#slist_reversal_lasso7] Snapshot.new (Snapshot.inner n + 1) ] s4
          | s4 = bb9 ]
          
        | bb9 = s0
          [ s0 =  [ &n <- _32 ] (any [ any_ (_any:Snapshot.snap_ty int)-> (!  [ &_32 <- _any ] s1) ] ) | s1 = bb3 ]
           ]
         ]
      
    | bb10 = s0 [ s0 = -{resolve'1 self}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l () : usize
    | & self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self
    | & l : usize = l
    | & s1 : Snapshot.snap_ty (Seq.seq usize) = s1
    | & s2 : Snapshot.snap_ty (Seq.seq usize) = s2
    | & r : usize = any_l () : usize
    | & n : Snapshot.snap_ty int = any_l () : Snapshot.snap_ty int
    | & old_self : Snapshot.snap_ty (borrowed (ListReversalLasso_Memory_Type.t_memory)) = any_l () : Snapshot.snap_ty (borrowed (ListReversalLasso_Memory_Type.t_memory))
    | & _20 : bool = any_l () : bool
    | & _22 : usize = any_l () : usize
    | & _23 : borrowed usize = any_l () : borrowed usize
    | & _24 : borrowed usize = any_l () : borrowed usize
    | & _25 : borrowed usize = any_l () : borrowed usize
    | & _26 : borrowed (ListReversalLasso_Memory_Type.t_memory) = any_l () : borrowed (ListReversalLasso_Memory_Type.t_memory)
    | & _28 : usize = any_l () : usize
    | & _29 : borrowed usize = any_l () : borrowed usize
    | & _30 : borrowed usize = any_l () : borrowed usize
    | & _32 : Snapshot.snap_ty int = any_l () : Snapshot.snap_ty int ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso9] lasso'0 ( ^ self) result (Snapshot.inner s1) (Reverse.reverse (Snapshot.inner s2))}
      (! return' {result}) ]
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  function any_l (_ : 'b) : 'a
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 204 15 204 37
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 205 14 208 5
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 209 14 209 25
  use prelude.UIntSize
  use seq.Seq
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  use prelude.Int
  constant s  : Seq.seq usize
  constant i  : int
  constant p  : int
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 210 4 210 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  goal vc_find_ptr_in_seq : ([%#slist_reversal_lasso0] 0 <= i /\ i <= Seq.length s)
   -> match i = Seq.length s with
    | True -> [%#slist_reversal_lasso1] match Core_Option_Option_Type.C_None with
      | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s
       -> UIntSize.to_int (Seq.get s j) <> p
      | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
      end
    | False -> match UIntSize.to_int (Seq.get s i) = p with
      | True -> [%#slist_reversal_lasso1] match Core_Option_Option_Type.C_Some i with
        | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s
         -> UIntSize.to_int (Seq.get s j) <> p
        | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
        end
      | False -> (([%#slist_reversal_lasso0] 0 <= i + 1 /\ i + 1 <= Seq.length s)
      /\ 0 <= ([%#slist_reversal_lasso2] Seq.length s - i)
      /\ ([%#slist_reversal_lasso2] Seq.length s - (i + 1)) < ([%#slist_reversal_lasso2] Seq.length s - i))
      /\ (([%#slist_reversal_lasso1] match find_ptr_in_seq s (i + 1) p with
        | Core_Option_Option_Type.C_None -> forall j : int . i + 1 <= j /\ j < Seq.length s
         -> UIntSize.to_int (Seq.get s j) <> p
        | Core_Option_Option_Type.C_Some j -> i + 1 <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
        end)
       -> ([%#slist_reversal_lasso1] match find_ptr_in_seq s (i + 1) p with
        | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s
         -> UIntSize.to_int (Seq.get s j) <> p
        | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
        end))
      end
    end
end
module ListReversalLasso_Impl4_Pigeon_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 219 15 219 21
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 220 4 220 67
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 221 4 221 113
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 222 14 222 26
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 223 14 223 20
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 224 14 224 15
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 204 15 204 37
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 205 14 208 5
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 209 14 209 25
  let%span span9 = "../list_reversal_lasso.rs" 211 8 215 9
  use seq.Seq
  use seq_ext.SeqExt
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UIntSize
  use seq.Seq
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  use prelude.Int
  function find_ptr_in_seq'0 [#"../list_reversal_lasso.rs" 210 4 210 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq'0_def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq'0 s i p
  = ([%#span9] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq'0 s (i + 1) p
  )
  let rec find_ptr_in_seq'0 (s:Seq.seq usize) (i:int) (p:int) (return'  (ret:Core_Option_Option_Type.t_option int))= {[@expl:precondition] [%#slist_reversal_lasso6] 0
    <= i
    /\ i <= Seq.length s}
    any
    [ return' (result:Core_Option_Option_Type.t_option int)-> {result = find_ptr_in_seq'0 s i p} (! return' {result}) ]
    
  axiom find_ptr_in_seq'0_spec : forall s : Seq.seq usize, i : int, p : int . ([%#slist_reversal_lasso6] 0 <= i
  /\ i <= Seq.length s)
   -> ([%#slist_reversal_lasso7] match find_ptr_in_seq'0 s i p with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s
     -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
  constant s  : Seq.seq usize
  constant n  : int
  function pigeon [#"../list_reversal_lasso.rs" 225 4 225 42] (s : Seq.seq usize) (n : int) : bool
  goal vc_pigeon : ([%#slist_reversal_lasso2] forall j : int . forall i : int . 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> ([%#slist_reversal_lasso1] forall i : int . 0 <= i /\ i < Seq.length s  -> UIntSize.to_int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso0] 0 <= n)
   -> match n = 0 with
    | True -> ([%#slist_reversal_lasso4] true) && ([%#slist_reversal_lasso3] Seq.length s <= n)
    | False -> ([%#slist_reversal_lasso6] 0 <= 0 /\ 0 <= Seq.length s)
    /\ (([%#slist_reversal_lasso7] match find_ptr_in_seq'0 s 0 (n - 1) with
      | Core_Option_Option_Type.C_None -> forall j : int . 0 <= j /\ j < Seq.length s
       -> UIntSize.to_int (Seq.get s j) <> n - 1
      | Core_Option_Option_Type.C_Some j -> 0 <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = n - 1
      end)
     -> match find_ptr_in_seq'0 s 0 (n - 1) with
      | Core_Option_Option_Type.C_None -> ((([%#slist_reversal_lasso2] forall j : int . forall i : int . 0 <= i
      /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
      && ([%#slist_reversal_lasso1] forall i : int . 0 <= i /\ i < Seq.length s
       -> UIntSize.to_int (Seq.get s i) < n - 1)
      && ([%#slist_reversal_lasso0] 0 <= n - 1))
      /\ 0 <= ([%#slist_reversal_lasso5] n) /\ ([%#slist_reversal_lasso5] n - 1) < ([%#slist_reversal_lasso5] n))
      /\ (([%#slist_reversal_lasso4] pigeon s (n - 1)) && ([%#slist_reversal_lasso3] Seq.length s <= n - 1)
       -> ([%#slist_reversal_lasso4] pigeon s (n - 1)) && ([%#slist_reversal_lasso3] Seq.length s <= n))
      | Core_Option_Option_Type.C_Some i -> ([%#slist_reversal_lasso6] 0 <= i + 1 /\ i + 1 <= Seq.length s)
      /\ (([%#slist_reversal_lasso7] match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Core_Option_Option_Type.C_None -> forall j : int . i + 1 <= j /\ j < Seq.length s
         -> UIntSize.to_int (Seq.get s j) <> n - 1
        | Core_Option_Option_Type.C_Some j -> i + 1 <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = n - 1
        end)
       -> match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Core_Option_Option_Type.C_None -> ((([%#slist_reversal_lasso2] forall j : int . forall i' : int . 0 <= i'
        /\ i' < Seq.length (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s)))
        /\ 0 <= j
        /\ j < Seq.length (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) /\ i' <> j
         -> Seq.get (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) i'
        <> Seq.get (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) j)
        && ([%#slist_reversal_lasso1] forall i' : int . 0 <= i'
        /\ i' < Seq.length (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s)))
         -> UIntSize.to_int (Seq.get (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i
        + 1) (Seq.length s))) i')
        < n - 1)
        && ([%#slist_reversal_lasso0] 0 <= n - 1))
        /\ 0 <= ([%#slist_reversal_lasso5] n) /\ ([%#slist_reversal_lasso5] n - 1) < ([%#slist_reversal_lasso5] n))
        /\ (([%#slist_reversal_lasso4] pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i
        + 1) (Seq.length s))) (n - 1))
        && ([%#slist_reversal_lasso3] Seq.length (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i
        + 1) (Seq.length s)))
        <= n - 1)
         -> ([%#slist_reversal_lasso4] pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i
        + 1) (Seq.length s))) (n - 1))
        && ([%#slist_reversal_lasso3] Seq.length s <= n))
        | Core_Option_Option_Type.C_Some _ -> ([%#slist_reversal_lasso4] true)
        && ([%#slist_reversal_lasso3] Seq.length s <= n)
        end)
      end)
    end
end
module ListReversalLasso_Impl4_FindLassoAux_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 242 15 242 40
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 243 15 243 53
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 244 15 244 56
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 245 14 248 5
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 249 4 249 39
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 204 15 204 37
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 205 14 208 5
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 209 14 209 25
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span svec9 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span svec10 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span slist_reversal_lasso11 = "../list_reversal_lasso.rs" 219 15 219 21
  let%span slist_reversal_lasso12 = "../list_reversal_lasso.rs" 220 4 220 67
  let%span slist_reversal_lasso13 = "../list_reversal_lasso.rs" 221 4 221 113
  let%span slist_reversal_lasso14 = "../list_reversal_lasso.rs" 222 14 222 26
  let%span slist_reversal_lasso15 = "../list_reversal_lasso.rs" 223 14 223 20
  let%span slist_reversal_lasso16 = "../list_reversal_lasso.rs" 224 14 224 15
  let%span span17 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span18 = "" 0 0 0 0
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span20 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span21 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span22 = "../list_reversal_lasso.rs" 211 8 215 9
  let%span span23 = "../list_reversal_lasso.rs" 226 8 238 9
  let%span span24 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span25 = "../list_reversal_lasso.rs" 83 12 85 98
  let%span span26 = "../list_reversal_lasso.rs" 156 8 162 9
  let%span span27 = "../list_reversal_lasso.rs" 13 0 13 15
  let%span span28 = "../list_reversal_lasso.rs" 93 12 93 53
  let%span span29 = "../list_reversal_lasso.rs" 56 8 58 9
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'1 (self : Seq.seq usize) =
    [%#span17] true
  let rec invariant'1 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Seq.seq usize)
  let rec inv'1 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Seq.seq usize . inv'1 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span18] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'0 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#svec8] inv'0 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#svec8] inv'0 self)
   -> ([%#svec10] inv'1 (shallow_model'0 self))
  && ([%#svec9] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span19] inv'1 (shallow_model'0 self)
  let rec invariant'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  axiom inv'0 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'0 x = true
  use seq_ext.SeqExt
  use seq.Seq
  use seq.Seq
  function index_logic'1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span20] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self ix} (! return' {result}) ]
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span21] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self i} (! return' {result}) ]
    
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq'0 [#"../list_reversal_lasso.rs" 210 4 210 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq'0_def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq'0 s i p
  = ([%#span22] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq'0 s (i + 1) p
  )
  let rec find_ptr_in_seq'0 (s:Seq.seq usize) (i:int) (p:int) (return'  (ret:Core_Option_Option_Type.t_option int))= {[@expl:precondition] [%#slist_reversal_lasso5] 0
    <= i
    /\ i <= Seq.length s}
    any
    [ return' (result:Core_Option_Option_Type.t_option int)-> {result = find_ptr_in_seq'0 s i p} (! return' {result}) ]
    
  axiom find_ptr_in_seq'0_spec : forall s : Seq.seq usize, i : int, p : int . ([%#slist_reversal_lasso5] 0 <= i
  /\ i <= Seq.length s)
   -> ([%#slist_reversal_lasso6] match find_ptr_in_seq'0 s i p with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s
     -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
  use seq.Seq
  function pigeon'0 [#"../list_reversal_lasso.rs" 225 4 225 42] (s : Seq.seq usize) (n : int) : bool
  axiom pigeon'0_def : forall s : Seq.seq usize, n : int . pigeon'0 s n
  = ([%#span23] if n = 0 then
    true
  else
    match find_ptr_in_seq'0 s 0 (n - 1) with
      | Core_Option_Option_Type.C_None -> pigeon'0 s (n - 1)
      | Core_Option_Option_Type.C_Some i -> match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Core_Option_Option_Type.C_None -> pigeon'0 (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i
        + 1) (Seq.length s))) (n - 1)
        | Core_Option_Option_Type.C_Some _ -> true
        end
      end
  )
  let rec pigeon'0 (s:Seq.seq usize) (n:int) (return'  (ret:bool))= {[@expl:precondition] [%#slist_reversal_lasso13] forall j : int . forall i : int . 0
    <= i
    /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j}
    {[@expl:precondition] [%#slist_reversal_lasso12] forall i : int . 0 <= i /\ i < Seq.length s
     -> UIntSize.to_int (Seq.get s i) < n}
    {[@expl:precondition] [%#slist_reversal_lasso11] 0 <= n}
    any [ return' (result:bool)-> {result = pigeon'0 s n} (! return' {result}) ] 
  axiom pigeon'0_spec : forall s : Seq.seq usize, n : int . ([%#slist_reversal_lasso11] 0 <= n)
   -> ([%#slist_reversal_lasso12] forall i : int . 0 <= i /\ i < Seq.length s  -> UIntSize.to_int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso13] forall j : int . forall i : int . 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> ([%#slist_reversal_lasso15] pigeon'0 s n) && ([%#slist_reversal_lasso14] Seq.length s <= n)
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span24] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span25] first = (if h = l then last else Seq.get s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  let rec list_seg'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (last:usize) (l:int) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list_seg'0 self first s last l h} (! return' {result}) ]
    
  predicate lasso'0 [#"../list_reversal_lasso.rs" 155 4 155 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [%#span26] let mid = if Seq.length s2 = 0 then Seq.get s1 (Seq.length s1 - 1) else Seq.get s2 0 in Seq.length s1 > 0
    /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
     -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg'0 self first s1 mid 0 (Seq.length s1)
    /\ list_seg'0 self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  let rec lasso'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s1:Seq.seq usize) (s2:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lasso'0 self first s1 s2} (! return' {result}) ]
    
  constant null'0 : usize = [%#span27] (18446744073709551615 : usize)
  predicate list'0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [%#span28] list_seg'0 self first s null'0 0 (Seq.length s)
  let rec list'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list'0 self first s} (! return' {result}) ]
    
  predicate mem_is_well_formed'0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
    
   =
    [%#span29] forall i : usize . nonnull_ptr'0 self i
     -> index_logic'0 self i = null'0 \/ nonnull_ptr'0 self (index_logic'0 self i)
  let rec mem_is_well_formed'0 (self:ListReversalLasso_Memory_Type.t_memory) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = mem_is_well_formed'0 self} (! return' {result}) ]
    
  constant self  : ListReversalLasso_Memory_Type.t_memory
  constant first  : usize
  constant last  : usize
  constant s  : Seq.seq usize
  function find_lasso_aux [#"../list_reversal_lasso.rs" 250 4 250 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  goal vc_find_lasso_aux : ([%#slist_reversal_lasso2] list_seg'0 self first s last 0 (Seq.length s))
   -> ([%#slist_reversal_lasso1] last = null'0 \/ nonnull_ptr'0 self last)
   -> ([%#slist_reversal_lasso0] mem_is_well_formed'0 self)
   -> match last = null'0 with
    | True -> [%#slist_reversal_lasso3] match (s, Core_Option_Option_Type.C_None) with
      | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
      end
    | False -> ([%#slist_reversal_lasso5] 0 <= 0 /\ 0 <= Seq.length s)
    /\ (([%#slist_reversal_lasso6] match find_ptr_in_seq'0 s 0 (UIntSize.to_int last) with
      | Core_Option_Option_Type.C_None -> forall j : int . 0 <= j /\ j < Seq.length s
       -> UIntSize.to_int (Seq.get s j) <> UIntSize.to_int last
      | Core_Option_Option_Type.C_Some j -> 0 <= j
      /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = UIntSize.to_int last
      end)
     -> match find_ptr_in_seq'0 s 0 (UIntSize.to_int last) with
      | Core_Option_Option_Type.C_None -> ([%#svec8] inv'0 (ListReversalLasso_Memory_Type.memory_0 self))
      /\ (([%#svec10] inv'1 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
      && ([%#svec9] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
      <= UIntSize.to_int (max'0 : usize))
       -> (([%#slist_reversal_lasso13] forall j : int . forall i : int . 0 <= i
      /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
      && ([%#slist_reversal_lasso12] forall i : int . 0 <= i /\ i < Seq.length s
       -> UIntSize.to_int (Seq.get s i) < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
      && ([%#slist_reversal_lasso11] 0 <= Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))))
      /\ (([%#slist_reversal_lasso15] pigeon'0 s (Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))))
      && ([%#slist_reversal_lasso14] Seq.length s
      <= Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
       -> match pigeon'0 s (Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))) with
        | True -> ((([%#slist_reversal_lasso2] list_seg'0 self first (Seq.snoc s last) (index_logic'0 self last) 0 (Seq.length (Seq.snoc s last)))
        && ([%#slist_reversal_lasso1] index_logic'0 self last = null'0 \/ nonnull_ptr'0 self (index_logic'0 self last))
        && ([%#slist_reversal_lasso0] mem_is_well_formed'0 self))
        /\ 0
        <= ([%#slist_reversal_lasso4] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
        - Seq.length s)
        /\ ([%#slist_reversal_lasso4] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
        - Seq.length (Seq.snoc s last))
        < ([%#slist_reversal_lasso4] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
        - Seq.length s))
        /\ (([%#slist_reversal_lasso3] match find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last) with
          | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
          | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
          end)
         -> ([%#slist_reversal_lasso3] match find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last) with
          | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
          | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
          end))
        | False -> [%#slist_reversal_lasso3] match (s, Core_Option_Option_Type.C_None) with
          | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
          | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
          end
        end))
      | Core_Option_Option_Type.C_Some i -> [%#slist_reversal_lasso3] match (SeqExt.subsequence s 0 (i
      + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s))) with
        | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
        | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
        end
      end)
    end
end
module ListReversalLasso_Impl4_FindLasso_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 270 15 270 40
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 271 15 271 55
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 272 14 275 5
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 242 15 242 40
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 243 15 243 53
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 244 15 244 56
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 245 14 248 5
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 249 4 249 39
  let%span span8 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  let%span span14 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  let%span span15 = "../list_reversal_lasso.rs" 21 8 21 31
  let%span span16 = "../list_reversal_lasso.rs" 50 20 50 70
  let%span span17 = "../list_reversal_lasso.rs" 83 12 85 98
  let%span span18 = "../list_reversal_lasso.rs" 204 15 204 37
  let%span span19 = "../list_reversal_lasso.rs" 205 14 208 5
  let%span span20 = "../list_reversal_lasso.rs" 209 14 209 25
  let%span span21 = "../list_reversal_lasso.rs" 211 8 215 9
  let%span span22 = "../list_reversal_lasso.rs" 219 15 219 21
  let%span span23 = "../list_reversal_lasso.rs" 220 4 220 67
  let%span span24 = "../list_reversal_lasso.rs" 221 4 221 113
  let%span span25 = "../list_reversal_lasso.rs" 222 14 222 26
  let%span span26 = "../list_reversal_lasso.rs" 223 14 223 20
  let%span span27 = "../list_reversal_lasso.rs" 224 14 224 15
  let%span span28 = "../list_reversal_lasso.rs" 226 8 238 9
  let%span span29 = "../list_reversal_lasso.rs" 156 8 162 9
  let%span span30 = "../list_reversal_lasso.rs" 13 0 13 15
  let%span span31 = "../list_reversal_lasso.rs" 93 12 93 53
  let%span span32 = "../list_reversal_lasso.rs" 56 8 58 9
  let%span span33 = "../list_reversal_lasso.rs" 251 8 265 9
  use prelude.UIntSize
  use seq.Seq
  predicate invariant'1 (self : Seq.seq usize) =
    [%#span8] true
  let rec invariant'1 (self:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Seq.seq usize)
  let rec inv'1 (_x:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Seq.seq usize . inv'1 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = [%#span9] (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  let rec inv'0 (_x:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  function shallow_model'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  let rec shallow_model'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq usize))= {[@expl:precondition] [%#span10] inv'0 self}
    any [ return' (result:Seq.seq usize)-> {result = shallow_model'0 self} (! return' {result}) ] 
  axiom shallow_model'0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([%#span10] inv'0 self)
   -> ([%#span12] inv'1 (shallow_model'0 self))
  && ([%#span11] Seq.length (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  predicate invariant'0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [%#span13] inv'1 (shallow_model'0 self)
  let rec invariant'0 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  axiom inv'0 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv'0 x = true
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  use seq.Seq
  function index_logic'1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [%#span14] Seq.get (shallow_model'0 self) (UIntSize.to_int ix)
  let rec index_logic'1 (self:Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'1 self ix} (! return' {result}) ]
    
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [%#span15] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  let rec index_logic'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:usize))= any
    [ return' (result:usize)-> {result = index_logic'0 self i} (! return' {result}) ]
    
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [%#span16] Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
    <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  let rec nonnull_ptr'0 (self:ListReversalLasso_Memory_Type.t_memory) (i:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = nonnull_ptr'0 self i} (! return' {result}) ]
    
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span17] first = (if h = l then last else Seq.get s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  let rec list_seg'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (last:usize) (l:int) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list_seg'0 self first s last l h} (! return' {result}) ]
    
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq'0 [#"../list_reversal_lasso.rs" 210 4 210 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq'0_def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq'0 s i p
  = ([%#span21] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq'0 s (i + 1) p
  )
  let rec find_ptr_in_seq'0 (s:Seq.seq usize) (i:int) (p:int) (return'  (ret:Core_Option_Option_Type.t_option int))= {[@expl:precondition] [%#span18] 0
    <= i
    /\ i <= Seq.length s}
    any
    [ return' (result:Core_Option_Option_Type.t_option int)-> {result = find_ptr_in_seq'0 s i p} (! return' {result}) ]
    
  axiom find_ptr_in_seq'0_spec : forall s : Seq.seq usize, i : int, p : int . ([%#span18] 0 <= i /\ i <= Seq.length s)
   -> ([%#span19] match find_ptr_in_seq'0 s i p with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s
     -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
  use seq_ext.SeqExt
  use seq.Seq
  use seq.Seq
  function pigeon'0 [#"../list_reversal_lasso.rs" 225 4 225 42] (s : Seq.seq usize) (n : int) : bool
  axiom pigeon'0_def : forall s : Seq.seq usize, n : int . pigeon'0 s n
  = ([%#span28] if n = 0 then
    true
  else
    match find_ptr_in_seq'0 s 0 (n - 1) with
      | Core_Option_Option_Type.C_None -> pigeon'0 s (n - 1)
      | Core_Option_Option_Type.C_Some i -> match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Core_Option_Option_Type.C_None -> pigeon'0 (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i
        + 1) (Seq.length s))) (n - 1)
        | Core_Option_Option_Type.C_Some _ -> true
        end
      end
  )
  let rec pigeon'0 (s:Seq.seq usize) (n:int) (return'  (ret:bool))= {[@expl:precondition] [%#span24] forall j : int . forall i : int . 0
    <= i
    /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j}
    {[@expl:precondition] [%#span23] forall i : int . 0 <= i /\ i < Seq.length s  -> UIntSize.to_int (Seq.get s i) < n}
    {[@expl:precondition] [%#span22] 0 <= n}
    any [ return' (result:bool)-> {result = pigeon'0 s n} (! return' {result}) ] 
  axiom pigeon'0_spec : forall s : Seq.seq usize, n : int . ([%#span22] 0 <= n)
   -> ([%#span23] forall i : int . 0 <= i /\ i < Seq.length s  -> UIntSize.to_int (Seq.get s i) < n)
   -> ([%#span24] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
   -> Seq.get s i <> Seq.get s j)  -> ([%#span26] pigeon'0 s n) && ([%#span25] Seq.length s <= n)
  predicate lasso'0 [#"../list_reversal_lasso.rs" 155 4 155 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [%#span29] let mid = if Seq.length s2 = 0 then Seq.get s1 (Seq.length s1 - 1) else Seq.get s2 0 in Seq.length s1 > 0
    /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
     -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg'0 self first s1 mid 0 (Seq.length s1)
    /\ list_seg'0 self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  let rec lasso'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s1:Seq.seq usize) (s2:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lasso'0 self first s1 s2} (! return' {result}) ]
    
  constant null'0 : usize = [%#span30] (18446744073709551615 : usize)
  predicate list'0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [%#span31] list_seg'0 self first s null'0 0 (Seq.length s)
  let rec list'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (s:Seq.seq usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = list'0 self first s} (! return' {result}) ]
    
  predicate mem_is_well_formed'0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
    
   =
    [%#span32] forall i : usize . nonnull_ptr'0 self i
     -> index_logic'0 self i = null'0 \/ nonnull_ptr'0 self (index_logic'0 self i)
  let rec mem_is_well_formed'0 (self:ListReversalLasso_Memory_Type.t_memory) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = mem_is_well_formed'0 self} (! return' {result}) ]
    
  function find_lasso_aux'0 [#"../list_reversal_lasso.rs" 250 4 250 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  axiom find_lasso_aux'0_def : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . find_lasso_aux'0 self first last s
  = ([%#span33] if last = null'0 then
    (s, Core_Option_Option_Type.C_None)
  else
    match find_ptr_in_seq'0 s 0 (UIntSize.to_int last) with
      | Core_Option_Option_Type.C_None -> if pigeon'0 s (Seq.length (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))) then
        find_lasso_aux'0 self first (index_logic'0 self last) (Seq.snoc s last)
      else
        (s, Core_Option_Option_Type.C_None)
      
      | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i
      + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
      end
  )
  let rec find_lasso_aux'0 (self:ListReversalLasso_Memory_Type.t_memory) (first:usize) (last:usize) (s:Seq.seq usize) (return'  (ret:(Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))))= {[@expl:precondition] [%#slist_reversal_lasso5] list_seg'0 self first s last 0 (Seq.length s)}
    {[@expl:precondition] [%#slist_reversal_lasso4] last = null'0 \/ nonnull_ptr'0 self last}
    {[@expl:precondition] [%#slist_reversal_lasso3] mem_is_well_formed'0 self}
    any
    [ return' (result:(Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize)))-> {result
      = find_lasso_aux'0 self first last s}
      (! return' {result}) ]
    
  axiom find_lasso_aux'0_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . ([%#slist_reversal_lasso3] mem_is_well_formed'0 self)
   -> ([%#slist_reversal_lasso4] last = null'0 \/ nonnull_ptr'0 self last)
   -> ([%#slist_reversal_lasso5] list_seg'0 self first s last 0 (Seq.length s))
   -> ([%#slist_reversal_lasso6] match find_lasso_aux'0 self first last s with
    | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
    end)
  use seq.Seq
  constant self  : ListReversalLasso_Memory_Type.t_memory
  constant first  : usize
  function find_lasso [#"../list_reversal_lasso.rs" 276 4 276 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  goal vc_find_lasso : ([%#slist_reversal_lasso1] first = null'0 \/ nonnull_ptr'0 self first)
   -> ([%#slist_reversal_lasso0] mem_is_well_formed'0 self)
   -> (([%#slist_reversal_lasso5] list_seg'0 self first (Seq.empty : Seq.seq usize) first 0 (Seq.length (Seq.empty : Seq.seq usize)))
  && ([%#slist_reversal_lasso4] first = null'0 \/ nonnull_ptr'0 self first)
  && ([%#slist_reversal_lasso3] mem_is_well_formed'0 self))
  /\ (([%#slist_reversal_lasso6] match find_lasso_aux'0 self first first (Seq.empty : Seq.seq usize) with
    | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
    end)
   -> ([%#slist_reversal_lasso2] match find_lasso_aux'0 self first first (Seq.empty : Seq.seq usize) with
    | (s, Core_Option_Option_Type.C_None) -> list'0 self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> lasso'0 self first s1 s2
    end))
end
module ListReversalLasso_Impl0
  
end
module ListReversalLasso_Impl1
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 30 4 30 35
  goal index_refn : [%#slist_reversal_lasso0] true
end
module ListReversalLasso_Impl2
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 41 4 41 47
  goal index_mut_refn : [%#slist_reversal_lasso0] true
end
